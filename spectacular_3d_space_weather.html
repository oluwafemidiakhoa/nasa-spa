<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåå NASA SPECTACULAR 3D SPACE WEATHER OBSERVATORY</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: radial-gradient(ellipse at center, #0a0a1a 0%, #000000 100%);
            color: #ffffff;
            font-family: 'Rajdhani', sans-serif;
            overflow: hidden;
            cursor: none;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 70%, rgba(87, 189, 232, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 90% 90%, rgba(255, 183, 77, 0.1) 0%, transparent 50%);
            animation: nebula 30s ease-in-out infinite;
            pointer-events: none;
            z-index: -1;
        }

        @keyframes nebula {
            0%, 100% { opacity: 0.8; transform: scale(1) rotate(0deg); }
            50% { opacity: 1; transform: scale(1.1) rotate(2deg); }
        }

        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        .custom-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid #4a90e2;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            transition: transform 0.1s ease;
            box-shadow: 0 0 10px rgba(74, 144, 226, 0.5);
        }

        .hud-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .hud-panel {
            position: absolute;
            background: linear-gradient(135deg, rgba(20, 30, 40, 0.95), rgba(30, 40, 50, 0.90));
            border: 1px solid rgba(74, 144, 226, 0.4);
            border-radius: 8px;
            padding: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 
                0 0 20px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            pointer-events: auto;
            font-family: 'Orbitron', monospace;
        }

        .hud-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 12px;
            padding: 1px;
            background: linear-gradient(45deg, rgba(74, 144, 226, 0.3), rgba(100, 150, 200, 0.3));
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: exclude;
            animation: borderGlow 5s linear infinite;
        }

        @keyframes borderGlow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        #mission-control {
            top: 15px;
            left: 15px;
            min-width: 220px;
        }

        #observatory-data {
            top: 15px;
            right: 15px;
            min-width: 240px;
            max-height: 50vh;
            overflow-y: auto;
        }

        #physics-panel {
            bottom: 15px;
            left: 15px;
            min-width: 300px;
        }

        #alert-panel {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            min-width: 600px;
            background: linear-gradient(135deg, rgba(255, 0, 0, 0.9), rgba(150, 0, 0, 0.8));
            border-color: #ff0000;
            display: none;
        }

        .panel-title {
            color: #4a90e2;
            font-size: 1rem;
            font-weight: 700;
            margin-bottom: 12px;
            text-align: center;
            text-transform: uppercase;
            text-shadow: 0 0 5px rgba(74, 144, 226, 0.3);
            letter-spacing: 1px;
        }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-bottom: 12px;
        }

        .status-metric {
            background: rgba(74, 144, 226, 0.1);
            border: 1px solid rgba(74, 144, 226, 0.3);
            border-radius: 6px;
            padding: 8px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .status-metric::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(74, 144, 226, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .status-metric:hover::before {
            left: 100%;
        }

        .metric-value {
            font-size: 1.2rem;
            font-weight: 700;
            color: #5cb85c;
            margin-bottom: 3px;
            text-shadow: 0 0 3px rgba(92, 184, 92, 0.3);
        }

        .metric-label {
            font-size: 0.7rem;
            color: #cccccc;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .controls-section {
            margin-bottom: 12px;
        }

        .control-label {
            color: #f0ad4e;
            font-size: 0.8rem;
            font-weight: 600;
            margin-bottom: 6px;
            display: block;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .control-btn {
            background: linear-gradient(135deg, #4a90e2, #5ba3f5);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-size: 0.7rem;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .control-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.3s ease;
        }

        .control-btn:hover {
            background: linear-gradient(135deg, #0099ff, #00ccff);
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 153, 255, 0.4);
        }

        .control-btn:hover::before {
            left: 100%;
        }

        .control-btn.active {
            background: linear-gradient(135deg, #ff6600, #ff9900);
            box-shadow: 0 0 20px rgba(255, 153, 0, 0.6);
        }

        .event-card {
            background: linear-gradient(135deg, rgba(255, 128, 0, 0.2), rgba(255, 64, 0, 0.1));
            border: 1px solid #ff8000;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .event-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #ff8000, #ffff00, #ff8000);
            animation: pulse 2s ease-in-out infinite;
        }

        .event-card:hover {
            background: linear-gradient(135deg, rgba(255, 128, 0, 0.4), rgba(255, 64, 0, 0.2));
            transform: translateX(10px);
            box-shadow: 0 5px 25px rgba(255, 128, 0, 0.4);
        }

        .event-header {
            color: #ff8000;
            font-weight: 700;
            font-size: 1.1rem;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .event-details {
            color: #cccccc;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .physics-display {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            padding: 20px;
            margin-top: 15px;
        }

        .physics-equation {
            font-family: 'Orbitron', monospace;
            color: #00ffff;
            font-size: 1.1rem;
            margin: 10px 0;
            text-align: center;
            text-shadow: 0 0 10px #00ffff;
        }

        .loading-animation {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 2rem;
            z-index: 2000;
            animation: pulse 1.5s ease-in-out infinite;
        }

        .top-status-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.95), rgba(0, 30, 60, 0.9));
            backdrop-filter: blur(10px);
            border-bottom: 2px solid rgba(74, 144, 226, 0.3);
            display: grid;
            grid-template-columns: 200px 1fr 200px;
            align-items: center;
            gap: 20px;
            padding: 0 20px;
            font-family: 'Orbitron', monospace;
            z-index: 1100;
            pointer-events: auto;
        }

        .mission-clock {
            font-size: 1.4rem;
            font-weight: 700;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            font-family: 'Orbitron', monospace;
            white-space: nowrap;
        }

        .system-name {
            font-size: 0.9rem;
            font-weight: 600;
            color: #ffffff;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }

        .system-name #systemTitle {
            white-space: nowrap;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            color: #00ff00;
            white-space: nowrap;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
        }

        .status-dot.green {
            background: #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.6);
        }

        .status-dot.yellow {
            background: #ffff00;
            box-shadow: 0 0 10px rgba(255, 255, 0, 0.6);
        }

        .status-dot.red {
            background: #ff0000;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.6);
        }

        .connection-status {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-online { background: #00ff00; box-shadow: 0 0 10px #00ff00; }
        .status-loading { background: #ffff00; box-shadow: 0 0 10px #ffff00; }
        .status-offline { background: #ff0000; box-shadow: 0 0 10px #ff0000; }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.9); }
        }

        .slider-container {
            margin: 15px 0;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ffff, #0080ff);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .emergency-alert {
            animation: alertBlink 1s ease-in-out infinite;
        }

        @keyframes alertBlink {
            0%, 100% { background: rgba(255, 0, 0, 0.8); }
            50% { background: rgba(255, 100, 0, 0.8); }
        }

        @media (max-width: 768px) {
            .hud-panel {
                padding: 15px;
                font-size: 0.9rem;
            }
            
            .status-grid {
                grid-template-columns: 1fr;
            }
            
            #mission-control, #observatory-data, #physics-panel {
                position: relative;
                top: auto;
                left: auto;
                right: auto;
                bottom: auto;
                margin: 10px;
                min-width: auto;
            }
        }

        /* Help Center Styles */
        .help-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
        }

        .help-content {
            background: linear-gradient(135deg, rgba(10, 10, 30, 0.95), rgba(20, 20, 50, 0.95));
            border: 2px solid rgba(74, 144, 226, 0.6);
            border-radius: 20px;
            padding: 30px;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
        }

        .help-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            border-bottom: 2px solid rgba(74, 144, 226, 0.3);
            padding-bottom: 15px;
        }

        .help-header h2 {
            color: #4a90e2;
            font-family: 'Orbitron', monospace;
            font-size: 1.8rem;
            margin: 0;
            text-shadow: 0 0 10px rgba(74, 144, 226, 0.5);
        }

        .help-close {
            background: rgba(255, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .help-close:hover {
            background: rgba(255, 0, 0, 0.9);
            transform: scale(1.1);
        }

        .help-sections {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
        }

        .help-section {
            background: rgba(0, 20, 40, 0.6);
            border: 1px solid rgba(74, 144, 226, 0.3);
            border-radius: 10px;
            padding: 20px;
        }

        .help-section h3 {
            color: #00ff80;
            font-family: 'Orbitron', monospace;
            margin-bottom: 15px;
            font-size: 1.2rem;
            text-shadow: 0 0 5px rgba(0, 255, 128, 0.3);
        }

        .help-section ul {
            list-style: none;
            padding: 0;
        }

        .help-section li {
            margin-bottom: 8px;
            padding-left: 15px;
            position: relative;
            color: #e0e0e0;
            line-height: 1.4;
        }

        .help-section li::before {
            content: '‚ñ∂';
            position: absolute;
            left: 0;
            color: #4a90e2;
        }

        .help-section a {
            color: #4a90e2;
            text-decoration: none;
        }

        .help-section a:hover {
            color: #00ff80;
            text-shadow: 0 0 5px rgba(0, 255, 128, 0.3);
        }

        /* Story Mode Styles */
        .mode-toggle-btn {
            background: linear-gradient(135deg, #ff6b6b, #ff8e8e);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            font-family: 'Orbitron', monospace;
            font-size: 0.75rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 3px 10px rgba(255, 107, 107, 0.3);
            white-space: nowrap;
        }

        .mode-toggle-btn:hover {
            background: linear-gradient(135deg, #ff5252, #ff7979);
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(255, 107, 107, 0.5);
        }

        .mode-toggle-btn.story-active {
            background: linear-gradient(135deg, #ffd93d, #ffb347);
            color: #000;
            box-shadow: 0 4px 15px rgba(255, 217, 61, 0.5);
        }

        /* Story Mode Interface - Cleaner & Less Busy */
        .story-mode-active {
            filter: saturate(1.4) brightness(1.15);
        }

        /* Hide observatory panel in story mode to reduce clutter */
        .story-mode-active #observatory-data {
            display: none !important;
        }

        /* Make panels more compact and subtle */
        .story-mode-active #mission-control {
            opacity: 0.92;
            max-width: 240px;
        }

        .story-mode-active #physics-panel {
            opacity: 0.92;
            max-width: 270px;
        }

        .story-mode-active .hud-panel {
            background: linear-gradient(135deg, rgba(255, 217, 61, 0.12), rgba(255, 179, 71, 0.12));
            border: 2px solid rgba(255, 217, 61, 0.6);
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(255, 217, 61, 0.25);
        }

        .story-mode-active .panel-title {
            color: #ffd93d;
            font-size: 1rem;
            text-shadow: 0 0 10px rgba(255, 217, 61, 0.6);
        }

        .story-mode-active .control-btn {
            background: linear-gradient(135deg, #ffd93d, #ffb347);
            color: #000;
            font-weight: 600;
            font-size: 0.8rem;
            padding: 10px 15px;
            border-radius: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 15px rgba(255, 217, 61, 0.3);
            transition: all 0.2s ease;
        }

        .story-mode-active .control-btn:hover {
            background: linear-gradient(135deg, #ffed4e, #ffc947);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 217, 61, 0.4);
        }

        /* Kid-Friendly Enhancements - Toned Down */
        .story-mode-active .metric-value {
            font-size: 1.2rem;
            color: #ff6b6b;
            text-shadow: 0 0 5px rgba(255, 107, 107, 0.3);
        }

        .story-mode-active .status-metric {
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.15), rgba(255, 140, 140, 0.1));
            border: 2px solid rgba(255, 107, 107, 0.4);
            border-radius: 12px;
        }

        .story-mode-active .status-metric:hover {
            transform: scale(1.02);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.25);
        }

        /* Fun animations for kids - Simplified & Smooth */
        .story-mode-active .event-card {
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.2), rgba(68, 179, 217, 0.12));
            border: 2px solid #4ecdc4;
            border-radius: 15px;
            transition: all 0.3s ease;
        }

        .story-mode-active .event-card:hover {
            transform: scale(1.02);
            box-shadow: 0 8px 25px rgba(78, 205, 196, 0.3);
        }

        /* Sliders - More accessible for kids but not overwhelming */
        .story-mode-active .slider {
            height: 10px;
            border-radius: 5px;
            background: linear-gradient(90deg, #ff6b6b, #ffd93d, #4ecdc4);
        }

        .story-mode-active .slider::-webkit-slider-thumb {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #ff6b6b, #ff8e8e);
            border: 2px solid white;
            box-shadow: 0 3px 12px rgba(255, 107, 107, 0.4);
            transition: all 0.2s ease;
        }

        .story-mode-active .slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 16px rgba(255, 107, 107, 0.5);
        }

        /* Story Character Panel - Simplified & Cleaner */
        .story-character-panel {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(255, 217, 61, 0.96), rgba(255, 179, 71, 0.94));
            border: 3px solid #ffd93d;
            border-radius: 20px;
            padding: 20px 30px;
            max-width: 600px;
            width: 90%;
            display: none;
            color: #000;
            font-family: 'Orbitron', monospace;
            box-shadow: 0 10px 40px rgba(255, 217, 61, 0.4);
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .story-character-panel.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            animation: panelSlideUp 0.5s ease-out;
        }

        @keyframes panelSlideUp {
            from {
                transform: translateX(-50%) translateY(100%);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }

        .character-avatar {
            font-size: 3rem;
            text-align: center;
            margin-bottom: 10px;
            animation: gentlePulse 3s ease-in-out infinite;
            filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.2));
        }

        @keyframes gentlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .character-name {
            font-size: 1.2rem;
            font-weight: 700;
            text-align: center;
            margin-bottom: 12px;
            color: #d63031;
            text-shadow: 0 1px 2px rgba(214, 48, 49, 0.3);
        }

        .character-dialogue {
            font-size: 1rem;
            line-height: 1.4;
            text-align: center;
            background: rgba(255, 255, 255, 0.4);
            padding: 15px 20px;
            border-radius: 12px;
            margin-bottom: 15px;
            border: 2px solid rgba(255, 255, 255, 0.6);
            box-shadow: inset 0 1px 3px rgba(255, 255, 255, 0.3);
            max-height: 120px;
            overflow-y: auto;
            transition: all 0.3s ease;
        }

        .character-dialogue.speaking {
            background: rgba(255, 255, 255, 0.6);
            border-color: rgba(255, 107, 107, 0.8);
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.4);
            animation: speakingPulse 1.5s ease-in-out infinite;
        }

        @keyframes speakingPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .character-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .character-btn {
            background: linear-gradient(135deg, #e74c3c, #ec7063);
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 20px;
            font-family: 'Orbitron', monospace;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 3px 10px rgba(231, 76, 60, 0.3);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
        }

        .character-btn:hover {
            background: linear-gradient(135deg, #c0392b, #e74c3c);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.4);
        }

        .character-btn:active {
            transform: translateY(0px);
        }

        .character-btn.speak-btn {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            animation: speakButtonPulse 2s ease-in-out infinite;
        }

        .character-btn.speak-btn:hover {
            background: linear-gradient(135deg, #229954, #27ae60);
        }

        @keyframes speakButtonPulse {
            0%, 100% { box-shadow: 0 3px 10px rgba(39, 174, 96, 0.3); }
            50% { box-shadow: 0 5px 20px rgba(39, 174, 96, 0.6); }
        }

        /* Story Mode Notification */
        .story-notification {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #ffd93d, #ffb347);
            color: #000;
            padding: 15px 30px;
            border-radius: 30px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            font-size: 1rem;
            box-shadow: 0 10px 30px rgba(255, 217, 61, 0.5);
            z-index: 10000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .story-notification.show {
            opacity: 1;
            animation: notificationSlide 0.5s ease-out;
        }

        @keyframes notificationSlide {
            from { transform: translateX(-50%) translateY(-20px); }
            to { transform: translateX(-50%) translateY(0); }
        }

        /* Story Chapter Navigation - Simplified */
        .story-chapter-btn {
            background: linear-gradient(135deg, #3498db, #2980b9) !important;
            color: white !important;
            font-size: 0.75rem !important;
            padding: 8px 12px !important;
            margin-bottom: 6px;
            border-radius: 10px !important;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
            white-space: nowrap;
            text-overflow: ellipsis;
            overflow: hidden;
        }

        .story-chapter-btn:hover {
            background: linear-gradient(135deg, #2980b9, #3498db) !important;
            transform: translateY(-1px) !important;
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4) !important;
        }

        .story-chapter-btn.active {
            background: linear-gradient(135deg, #e74c3c, #c0392b) !important;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.5) !important;
            font-weight: 700 !important;
        }

        .story-chapter-btn.completed {
            background: linear-gradient(135deg, #27ae60, #229954) !important;
            position: relative;
            padding-right: 30px !important;
        }

        .story-chapter-btn.completed::after {
            content: '‚úì';
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-weight: bold;
            color: white;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="custom-cursor" id="custom-cursor"></div>
    <div id="canvas-container"></div>
    
    <div class="loading-animation" id="loading">
        üåå INITIALIZING SPACE WEATHER OBSERVATORY...
    </div>
    
    <div class="hud-overlay">
        <!-- Professional Status Bar -->
        <div class="top-status-bar">
            <div class="mission-clock" id="missionClock">00:00:00</div>
            <div class="system-name">
                <span id="systemTitle">üåå SPECTACULAR SPACE OBSERVATORY</span>
                <div class="mode-toggle-container" style="margin-left: 20px;">
                    <button class="mode-toggle-btn" onclick="window.location.href='dashboard_hub.html'" style="background: linear-gradient(135deg, #00d4ff, #0099cc);">
                        üè† DASHBOARD
                    </button>
                </div>
            </div>
            <div class="status-indicator">
                <div class="status-dot green"></div>
                <span id="systemStatus">OPERATIONAL</span>
            </div>
        </div>

        <!-- Mission Control Panel -->
        <div id="mission-control" class="hud-panel">
            <div class="panel-title">üõ∞Ô∏è MISSION CONTROL</div>
            
            <div class="status-grid">
                <div class="status-metric">
                    <div class="metric-value" id="cme-count">0</div>
                    <div class="metric-label">CME Events</div>
                </div>
                <div class="status-metric">
                    <div class="metric-value" id="flare-count">0</div>
                    <div class="metric-label">Solar Flares</div>
                </div>
                <div class="status-metric">
                    <div class="metric-value" id="activity-level">QUIET</div>
                    <div class="metric-label">Activity Level</div>
                </div>
                <div class="status-metric">
                    <div class="metric-value connection-status" id="data-status">
                        <span class="status-indicator status-loading"></span>INIT
                    </div>
                    <div class="metric-label">Data Stream</div>
                </div>
            </div>

            <div class="controls-section">
                <div class="control-label">üéÆ Visualization Controls</div>
                <div class="control-buttons">
                    <button class="control-btn" onclick="toggleAnimation()">‚èØÔ∏è Animation</button>
                    <button class="control-btn" onclick="resetView()">üîÑ Reset</button>
                    <button class="control-btn" onclick="toggleFullscreen()">üñºÔ∏è Fullscreen</button>
                    <button class="control-btn" onclick="captureScreenshot()">üì∏ Capture</button>
                </div>
            </div>

            <div class="controls-section">
                <div class="control-label">üåç Camera Modes</div>
                <div class="control-buttons">
                    <button class="control-btn active" onclick="setCameraMode('overview')" id="btn-overview">Overview</button>
                    <button class="control-btn" onclick="setCameraMode('earth')" id="btn-earth">Earth Focus</button>
                    <button class="control-btn" onclick="setCameraMode('sun')" id="btn-sun">Sun Focus</button>
                    <button class="control-btn" onclick="setCameraMode('cinematic')" id="btn-cinematic">Cinematic</button>
                </div>
            </div>

            <div class="slider-container">
                <div class="control-label">‚ö° Simulation Speed</div>
                <input type="range" class="slider" id="time-speed" min="0.1" max="5" step="0.1" value="1" onchange="updateTimeSpeed(this.value)">
                <div style="text-align: center; color: #00ffff; margin-top: 5px;">
                    <span id="speed-display">1.0x</span>
                </div>
            </div>

            <div class="slider-container">
                <div class="control-label">üåÄ Particle Intensity</div>
                <input type="range" class="slider" id="particle-intensity" min="0.1" max="3" step="0.1" value="1" onchange="updateParticleIntensity(this.value)">
            </div>
        </div>

        <!-- Observatory Data Panel -->
        <div id="observatory-data" class="hud-panel">
            <div class="panel-title">üì° LIVE OBSERVATORY DATA</div>
            <div id="events-container">
                <div style="text-align: center; color: #00ffff; margin: 20px 0;">
                    üåÄ Loading NASA DONKI data stream...
                </div>
            </div>
        </div>

        <!-- Physics Panel -->
        <div id="physics-panel" class="hud-panel">
            <div class="panel-title">üî¨ SPACE PHYSICS ENGINE</div>
            
            <div class="physics-display">
                <div style="color: #ffff00; font-weight: 600; margin-bottom: 10px;">Real-Time Calculations:</div>
                <div class="physics-equation" id="physics-eq1">v = ‚àö(GM/r) = <span id="orbital-velocity">29.78</span> km/s</div>
                <div class="physics-equation" id="physics-eq2">B = Œº‚ÇÄM/(4œÄr¬≥) = <span id="magnetic-field">3.12√ó10‚Åª‚Åµ</span> T</div>
                <div class="physics-equation" id="physics-eq3">Dst = -<span id="dst-index">15</span> nT</div>
            </div>

            <div style="margin-top: 15px;">
                <div class="control-label">üß™ Physics Models</div>
                <div class="control-buttons">
                    <button class="control-btn active" onclick="togglePhysicsModel('cme')" id="btn-cme-model">CME Drag</button>
                    <button class="control-btn active" onclick="togglePhysicsModel('solar-wind')" id="btn-sw-model">Solar Wind</button>
                    <button class="control-btn active" onclick="togglePhysicsModel('magnetic')" id="btn-mag-model">Magnetic</button>
                </div>
            </div>

            <div style="margin-top: 20px; text-align: center;">
                <button class="control-btn" onclick="openHelpCenter()" style="background: linear-gradient(135deg, #28a745, #20c997);">
                    ‚ùì Help & Guide
                </button>
            </div>
        </div>

        <!-- Emergency Alert Panel -->
        <div id="alert-panel" class="hud-panel emergency-alert">
            <div class="panel-title">‚ö†Ô∏è SPACE WEATHER ALERT</div>
            <div id="alert-content">
                <div style="font-size: 1.2rem; margin-bottom: 15px;">HIGH-SPEED CME DETECTED</div>
                <div>Speed: 1,200 km/s | ETA: 18 hours | Risk Level: SEVERE</div>
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <button class="control-btn" onclick="dismissAlert()">ACKNOWLEDGE</button>
            </div>
        </div>
    </div>
    <!-- End HUD Overlay -->

    <!-- Help Center Modal (Outside HUD) -->
    <div id="help-center" class="help-modal" style="display: none;">
        <div class="help-content">
            <div class="help-header">
                <h2>üåå 3D Space Weather Observatory - Help Center</h2>
                <button class="help-close" onclick="closeHelpCenter()">&times;</button>
            </div>

            <div class="help-sections">
                    <div class="help-section">
                        <h3>üéÆ Controls & Navigation</h3>
                        <ul>
                            <li><strong>Mouse:</strong> Left-click + drag to rotate view</li>
                            <li><strong>Scroll:</strong> Zoom in/out</li>
                            <li><strong>Right-click + drag:</strong> Pan camera</li>
                            <li><strong>Keyboard:</strong> WASD for movement, Arrow keys for camera control</li>
                            <li><strong>Space:</strong> Pause/resume animation</li>
                            <li><strong>R:</strong> Reset camera view</li>
                        </ul>
                    </div>

                    <div class="help-section">
                        <h3>üõ∞Ô∏è Mission Control Panel</h3>
                        <ul>
                            <li><strong>Animation:</strong> Toggle time-based simulation</li>
                            <li><strong>Reset:</strong> Return to default view</li>
                            <li><strong>Fullscreen:</strong> Immersive viewing mode</li>
                            <li><strong>Capture:</strong> Take screenshot of current view</li>
                            <li><strong>Camera Modes:</strong> Switch between observation perspectives</li>
                            <li><strong>Speed Control:</strong> Adjust simulation time rate</li>
                        </ul>
                    </div>

                    <div class="help-section">
                        <h3>üß™ Physics Models</h3>
                        <ul>
                            <li><strong>CME Drag Model:</strong> Simulates Coronal Mass Ejection propagation with solar wind resistance</li>
                            <li><strong>Solar Wind:</strong> Real-time solar wind speed and density modeling</li>
                            <li><strong>Magnetic Field:</strong> Earth's magnetosphere interaction visualization</li>
                            <li><strong>Dst Index:</strong> Geomagnetic storm intensity indicator</li>
                        </ul>
                    </div>

                    <div class="help-section">
                        <h3>üìä Data Interpretation</h3>
                        <ul>
                            <li><strong>Observatory Data:</strong> Live NASA satellite measurements</li>
                            <li><strong>Physics Panel:</strong> Real-time equations and calculations</li>
                            <li><strong>Event Alerts:</strong> Automated warnings for space weather events</li>
                            <li><strong>Color Coding:</strong> Green=Normal, Yellow=Watch, Red=Warning</li>
                        </ul>
                    </div>

                    <div class="help-section">
                        <h3>üö® Emergency Procedures</h3>
                        <ul>
                            <li><strong>Red Alerts:</strong> Immediate attention required</li>
                            <li><strong>ACKNOWLEDGE:</strong> Confirm alert awareness</li>
                            <li><strong>Data Sources:</strong> NOAA, NASA DONKI, SDO, SOHO</li>
                            <li><strong>Contact Support:</strong> support@helioearth.com</li>
                        </ul>
                    </div>

                    <div class="help-section">
                        <h3>üìû Support & Resources</h3>
                        <p><strong>Professional Space Weather Platform</strong></p>
                        <p>Email: <a href="mailto:support@helioearth.com">support@helioearth.com</a></p>
                        <p>Documentation: Real-time NASA data integration</p>
                        <p>Emergency Hotline: Contact your space weather coordinator</p>
                        <p>Training: Interactive 3D visualization tutorials available</p>
                    </div>
                </div>
            </div>
        </div>

    <script>
        // Global variables
        let scene, camera, renderer, composer;
        let sun, earth, moon, mercury, venus, mars;
        let sunParticles, earthMagnetosphere;
        let cmeObjects = [], flareObjects = [], solarWindParticles = [];
        let animationRunning = true;
        let timeSpeed = 1.0;
        let particleIntensity = 1.0;
        let cameraMode = 'overview';
        let nasaData = null;
        let physicsModels = { cme: true, solarWind: true, magnetic: true };
        let stats, gui;
        
        // Story Mode Variables
        let storyMode = false;
        let currentCharacter = 'sunny';
        let currentDialogueIndex = 0;
        let speechSynthesis = window.speechSynthesis;
        
        // Story Characters and Dialogues
        const storyCharacters = {
            sunny: {
                name: "Sunny the Sun",
                avatar: "üåû",
                dialogues: [
                    "Hi there, young space explorer! I'm Sunny, and I create all the space weather you see here!",
                    "I'm always bustling with activity - creating solar flares and coronal mass ejections!",
                    "Sometimes I get really excited and send my energy toward Earth. Want to see?",
                    "Click on me to make me more active! Let's create some space weather together!"
                ]
            },
            terra: {
                name: "Terra the Earth",
                avatar: "üåç",
                dialogues: [
                    "Hello! I'm Terra, and I protect everyone on Earth from space weather!",
                    "I have a magical shield called a magnetosphere that deflects most of Sunny's energy!",
                    "When space weather reaches me, I create beautiful auroras at my poles!",
                    "Want to see how I protect the people, plants, and animals on my surface?"
                ]
            },
            luna: {
                name: "Luna the Moon",
                avatar: "üåô",
                dialogues: [
                    "Hi! I'm Luna, Terra's best friend! I orbit around her all the time!",
                    "I don't have a magnetic shield like Terra, so space weather affects me differently!",
                    "Astronauts visiting me need special protection during solar storms!",
                    "I help scientists learn about space weather by reflecting Sunny's light!"
                ]
            },
            aurora: {
                name: "Captain Aurora",
                avatar: "‚ú®",
                dialogues: [
                    "Greetings, space cadet! I'm Captain Aurora, guardian of space weather!",
                    "I monitor all of Sunny's activities and warn people when big storms are coming!",
                    "My job is to keep astronauts, pilots, and everyone on Earth safe!",
                    "Let me show you how we predict and prepare for space weather events!"
                ]
            }
        };
        
        // Story Chapters
        const storyChapters = {
            1: { title: "Meet Sunny the Bustling Sun", character: "sunny", cameraMode: "sun" },
            2: { title: "The Great Space Journey", character: "aurora", cameraMode: "overview" },
            3: { title: "Heroes Respond on Earth", character: "terra", cameraMode: "earth" },
            4: { title: "The Aurora Dance", character: "aurora", cameraMode: "earth" },
            5: { title: "Space Weather Guardians", character: "aurora", cameraMode: "overview" }
        };
        
        // Performance monitoring
        let frameCount = 0;
        let lastTime = 0;
        let fps = 60;
        let autoQuality = true;

        console.log('üöÄ Initializing Spectacular 3D Space Weather Observatory...');

        // Story Mode Notification System
        function showStoryNotification(message, duration = 3000) {
            const notification = document.getElementById('story-notification');
            if (!notification) return;

            notification.textContent = message;
            notification.classList.add('show');

            setTimeout(() => {
                notification.classList.remove('show');
            }, duration);
        }
        
        // Story Mode Functions
        function toggleStoryMode() {
            // Stop any currently playing voice when toggling modes
            if (isVoicePlaying) {
                stopCurrentVoice();
            }
            
            storyMode = !storyMode;
            const btn = document.getElementById('modeToggleBtn');
            const systemTitle = document.getElementById('systemTitle');
            const hudOverlay = document.querySelector('.hud-overlay');
            
            if (storyMode) {
                // Activate Story Mode
                btn.textContent = 'üöÄ PROFESSIONAL MODE';
                btn.classList.add('story-active');
                systemTitle.textContent = 'üìö INTERACTIVE SPACE WEATHER STORY';
                hudOverlay.classList.add('story-mode-active');
                showCharacterPanel();

                // Hide any active alerts in story mode
                hideAllAlerts();

                // Show story navigation
                document.getElementById('story-navigation').style.display = 'block';

                // Initialize first chapter as active
                currentChapter = 1;
                document.querySelectorAll('.story-chapter-btn').forEach(btn => btn.classList.remove('active'));
                const firstChapterBtn = document.getElementById('chapter-1-btn');
                if (firstChapterBtn) {
                    firstChapterBtn.classList.add('active');
                }

                // Update panel titles for kids
                const missionControlTitle = document.querySelector('#mission-control .panel-title');
                const observatoryTitle = document.querySelector('#observatory-data .panel-title');
                const physicsTitle = document.querySelector('#physics-panel .panel-title');

                if (missionControlTitle) missionControlTitle.textContent = 'üéÆ STORY CONTROLS';
                if (observatoryTitle) observatoryTitle.textContent = 'üìä SPACE WEATHER ADVENTURES';
                if (physicsTitle) physicsTitle.textContent = 'üß™ SPACE SCIENCE MAGIC';

                // Update button labels for kids
                const animBtn = document.querySelector('button[onclick="toggleAnimation()"]');
                const resetBtn = document.querySelector('button[onclick="resetView()"]');
                const captureBtn = document.querySelector('button[onclick="captureScreenshot()"]');

                if (animBtn) animBtn.innerHTML = '‚èØÔ∏è Play/Pause';
                if (resetBtn) resetBtn.innerHTML = 'üè† Home View';
                if (captureBtn) captureBtn.innerHTML = 'üì∑ Take Photo';

                console.log('üìö Story Mode Activated! Starting at Chapter 1');
            } else {
                // Return to Professional Mode
                btn.textContent = 'üìö STORY MODE';
                btn.classList.remove('story-active');
                systemTitle.textContent = 'üåå SPECTACULAR SPACE OBSERVATORY';
                hudOverlay.classList.remove('story-mode-active');
                hideCharacterPanel();

                // Hide story navigation
                const storyNav = document.getElementById('story-navigation');
                if (storyNav) storyNav.style.display = 'none';

                // Reset chapter state
                currentChapter = 1;
                completedChapters = [];
                document.querySelectorAll('.story-chapter-btn').forEach(btn => {
                    btn.classList.remove('active', 'completed');
                });

                // Restore professional titles
                const missionControlTitle = document.querySelector('#mission-control .panel-title');
                const observatoryTitle = document.querySelector('#observatory-data .panel-title');
                const physicsTitle = document.querySelector('#physics-panel .panel-title');

                if (missionControlTitle) missionControlTitle.textContent = 'üõ∞Ô∏è MISSION CONTROL';
                if (observatoryTitle) observatoryTitle.textContent = 'üì° LIVE OBSERVATORY DATA';
                if (physicsTitle) physicsTitle.textContent = 'üî¨ SPACE PHYSICS ENGINE';

                // Restore professional button labels
                const animBtn = document.querySelector('button[onclick="toggleAnimation()"]');
                const resetBtn = document.querySelector('button[onclick="resetView()"]');
                const captureBtn = document.querySelector('button[onclick="captureScreenshot()"]');

                if (animBtn) animBtn.innerHTML = '‚èØÔ∏è Animation';
                if (resetBtn) resetBtn.innerHTML = 'üîÑ Reset';
                if (captureBtn) captureBtn.innerHTML = 'üì∏ Capture';

                console.log('üöÄ Professional Mode Activated!');
            }
        }
        
        function showCharacterPanel() {
            const panel = document.getElementById('story-character-panel');
            panel.classList.add('active');
            updateCharacterDisplay();
        }
        
        function hideCharacterPanel() {
            const panel = document.getElementById('story-character-panel');
            panel.classList.remove('active');

            // Stop any playing voice when hiding
            if (isVoicePlaying) {
                stopCurrentVoice();
            }
        }

        function toggleCharacterPanel() {
            console.log('‚ú® ========== HIDE/SHOW BUTTON CLICKED ==========');

            try {
                const panel = document.getElementById('story-character-panel');
                if (!panel) {
                    console.error('‚ùå Character panel not found!');
                    alert('ERROR: Character panel not found!');
                    return;
                }

                console.log('‚úÖ Panel found:', panel);

                const isHidden = panel.style.display === 'none';
                console.log(`Panel currently hidden: ${isHidden}`);

                if (isHidden) {
                    // Show the panel
                    panel.style.display = 'block';
                    console.log('‚úÖ Character panel SHOWN');
                } else {
                    // Hide the panel
                    panel.style.display = 'none';
                    if (typeof isVoicePlaying !== 'undefined' && isVoicePlaying) {
                        stopCurrentVoice();
                    }
                    console.log('‚úÖ Character panel HIDDEN');
                }
            } catch (error) {
                console.error('‚ùå Error in toggleCharacterPanel:', error);
                alert('Error toggling panel: ' + error.message);
            }
        }
        
        function updateCharacterDisplay() {
            const character = storyCharacters[currentCharacter];
            document.getElementById('characterAvatar').textContent = character.avatar;
            document.getElementById('characterName').textContent = character.name;
            document.getElementById('characterDialogue').textContent = character.dialogues[currentDialogueIndex];
        }

        function setCharacterDialogue(text, autoSpeak = false) {
            // Clear any pending voice actions
            if (voiceTimeout) clearTimeout(voiceTimeout);

            // Stop any currently playing voice
            if (isVoicePlaying) {
                stopCurrentVoice();
            }

            // Update the current character's dialogue
            storyCharacters[currentCharacter].dialogues[currentDialogueIndex] = text;
            const dialogueElement = document.getElementById('characterDialogue');
            if (dialogueElement) {
                dialogueElement.textContent = text;
            }

            // DISABLED AUTO-SPEAK - Let user click Speak button manually
            // This prevents voice interruptions and incomplete sentences
            console.log(`üìù Dialogue updated: "${text.substring(0, 50)}..." (Auto-speak disabled)`);
        }
        
        // Voice management globals
        let currentAudio = null;
        let isVoicePlaying = false;

        // VOICE SYSTEM: Working version from space_weather_adventures.html
        async function speakNow() {
            console.log('üîä SPEAK BUTTON CLICKED!');

            const dialogueElement = document.getElementById('characterDialogue');
            if (!dialogueElement) {
                alert('ERROR: Dialogue element not found!');
                return;
            }

            const text = dialogueElement.textContent;
            console.log('Text:', text);

            const character = storyCharacters[currentCharacter];
            console.log('Character:', character);

            // Show speaking indicator
            const speakBtn = document.getElementById('speakBtn');
            if (!speakBtn) {
                alert('ERROR: Speak button not found!');
                return;
            }

            const originalText = speakBtn.innerHTML;
            speakBtn.innerHTML = 'üîä Speaking...';
            speakBtn.disabled = true;

            try {
                // Try ElevenLabs API first, fallback to browser TTS
                let audioUrl = null;

                // ElevenLabs Voice Configuration
                const voiceIds = {
                    sunny: 'pNInz6obpgDQGcFmaJgB',
                    terra: 'EXAVITQu4vr4xnSDxMaL',
                    luna: 'AZnzlk1XvdvUeBnXmlld',
                    aurora: 'TxGEqnHWrfWFTfGW9XjX'
                };

                // Try ElevenLabs API
                try {
                    const response = await fetch('/api/speak', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            text: text,
                            voice_id: voiceIds[currentCharacter] || voiceIds.aurora,
                            character: currentCharacter
                        })
                    });

                    if (response.ok) {
                        const blob = await response.blob();
                        audioUrl = URL.createObjectURL(blob);
                        console.log(`üéôÔ∏è Using ElevenLabs voice for ${character.name}`);
                    }
                } catch (error) {
                    console.log('ElevenLabs not available, using browser TTS...');
                }

                // Play the AI-generated audio or fallback to browser TTS
                if (audioUrl) {
                    const audio = new Audio(audioUrl);
                    audio.onended = () => {
                        URL.revokeObjectURL(audioUrl);
                        speakBtn.innerHTML = originalText;
                        speakBtn.disabled = false;
                    };
                    audio.onerror = () => {
                        console.log('Audio playback failed, using browser TTS...');
                        useBrowserTTS(text);
                        speakBtn.innerHTML = originalText;
                        speakBtn.disabled = false;
                    };
                    await audio.play();
                } else {
                    // Fallback to browser TTS
                    useBrowserTTS(text);
                    speakBtn.innerHTML = originalText;
                    speakBtn.disabled = false;
                }

            } catch (error) {
                console.error('Speech synthesis error:', error);
                useBrowserTTS(text);
                speakBtn.innerHTML = originalText;
                speakBtn.disabled = false;
            }
        }

        // Browser TTS fallback function
        function useBrowserTTS(text, character) {
            if (speechSynthesis.speaking) {
                speechSynthesis.cancel();
            }

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 0.8;
            utterance.pitch = currentCharacter === 'sunny' ? 1.2 :
                             currentCharacter === 'terra' ? 0.9 :
                             currentCharacter === 'luna' ? 1.1 : 1.0;
            utterance.volume = 0.8;

            speechSynthesis.speak(utterance);
            console.log(`üîä Using browser TTS for ${character ? character.name : 'character'}`);
        }

        async function speakCharacterDialogue() {
            const text = document.getElementById('characterDialogue').textContent;
            const character = storyCharacters[currentCharacter];

            // Show speaking indicator
            const speakBtn = document.querySelector('button[onclick="speakCharacterDialogue()"]');
            const originalText = speakBtn.innerHTML;
            speakBtn.innerHTML = 'üîä Speaking...';
            speakBtn.disabled = true;

            try {
                // Try ElevenLabs API first, fallback to OpenAI, then browser TTS
                let audioUrl = null;

                // ElevenLabs Voice Configuration
                const voiceIds = {
                    sunny: 'pNInz6obpgDQGcFmaJgB',
                    terra: 'EXAVITQu4vr4xnSDxMaL',
                    luna: 'AZnzlk1XvdvUeBnXmlld',
                    aurora: 'TxGEqnHWrfWFTfGW9XjX'
                };

                // Try ElevenLabs API
                try {
                    const response = await fetch('/api/speak', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            text: text,
                            voice_id: voiceIds[currentCharacter] || voiceIds.aurora,
                            character: currentCharacter
                        })
                    });

                    if (response.ok) {
                        const blob = await response.blob();
                        audioUrl = URL.createObjectURL(blob);
                        console.log(`üéôÔ∏è Using ElevenLabs voice for ${character.name}`);
                    }
                } catch (error) {
                    console.log('ElevenLabs not available, trying OpenAI...');
                }

                // Fallback to OpenAI TTS
                if (!audioUrl) {
                    try {
                        const response = await fetch('/api/openai-speak', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                text: text,
                                voice: currentCharacter === 'sunny' ? 'alloy' :
                                       currentCharacter === 'terra' ? 'nova' :
                                       currentCharacter === 'luna' ? 'shimmer' : 'onyx',
                                character: currentCharacter
                            })
                        });

                        if (response.ok) {
                            const blob = await response.blob();
                            audioUrl = URL.createObjectURL(blob);
                            console.log(`ü§ñ Using OpenAI voice for ${character.name}`);
                        }
                    } catch (error) {
                        console.log('OpenAI TTS not available, using browser TTS...');
                    }
                }

                // Play the AI-generated audio or fallback to browser TTS
                if (audioUrl) {
                    const audio = new Audio(audioUrl);
                    audio.onended = () => {
                        URL.revokeObjectURL(audioUrl);
                        speakBtn.innerHTML = originalText;
                        speakBtn.disabled = false;
                    };
                    audio.onerror = () => {
                        console.log('Audio playback failed, using browser TTS...');
                        useBrowserTTS(text, character);
                        speakBtn.innerHTML = originalText;
                        speakBtn.disabled = false;
                    };
                    await audio.play();
                } else {
                    // Fallback to browser TTS
                    useBrowserTTS(text, character);
                    speakBtn.innerHTML = originalText;
                    speakBtn.disabled = false;
                }

            } catch (error) {
                console.error('Speech synthesis error:', error);
                // Final fallback to browser TTS
                useBrowserTTS(text, character);
                speakBtn.innerHTML = originalText;
                speakBtn.disabled = false;
            }
        }

        function stopCurrentVoice() {
            // Stop audio playback
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
            }
            
            // Stop speech synthesis
            if (speechSynthesis.speaking) {
                speechSynthesis.cancel();
            }
            
            resetVoiceButton();
        }

        function resetVoiceButton() {
            const speakBtn = document.getElementById('speakBtn');
            if (speakBtn) {
                speakBtn.innerHTML = 'üîä Speak';
                speakBtn.disabled = false;
                speakBtn.style.opacity = '1';
            }
            isVoicePlaying = false;
        }

        function updateSpeakButton(speaking) {
            const speakBtn = document.getElementById('speakBtn');
            const dialogueElement = document.getElementById('characterDialogue');

            if (speakBtn) {
                if (speaking) {
                    speakBtn.innerHTML = '‚èπÔ∏è Stop';
                    speakBtn.classList.remove('speak-btn'); // Remove pulsing animation
                    speakBtn.style.background = 'linear-gradient(135deg, #e74c3c, #c0392b)';
                    if (dialogueElement) dialogueElement.classList.add('speaking');
                } else {
                    speakBtn.innerHTML = 'üîä Speak';
                    speakBtn.classList.add('speak-btn'); // Add pulsing animation back
                    speakBtn.style.background = '';
                    if (dialogueElement) dialogueElement.classList.remove('speaking');
                }
                speakBtn.disabled = false;
            }
        }
        
        function useBrowserTTS(text, character) {
            console.log('üé§ useBrowserTTS called');
            console.log(`   Text: "${text.substring(0, 50)}..."`);
            console.log(`   Speaking status: ${speechSynthesis.speaking}`);
            console.log(`   Pending status: ${speechSynthesis.pending}`);

            // Cancel any existing speech first
            if (speechSynthesis.speaking || speechSynthesis.pending) {
                console.log('‚ö†Ô∏è Cancelling existing speech...');
                speechSynthesis.cancel();
                // Small delay to ensure cancellation completes
                setTimeout(() => {
                    console.log('‚ñ∂Ô∏è Retrying after cancellation...');
                    startSpeaking();
                }, 150);
                return;
            }

            startSpeaking();

            function startSpeaking() {
                console.log('üöÄ startSpeaking() called');

                // Wait for voices to be available
                const voices = speechSynthesis.getVoices();
                console.log(`üéôÔ∏è Available voices: ${voices.length}`);

                if (voices.length === 0) {
                    console.warn('‚ö†Ô∏è No voices loaded yet, waiting for voiceschanged event...');
                    speechSynthesis.addEventListener('voiceschanged', () => {
                        console.log('‚úÖ Voices loaded, retrying...');
                        useBrowserTTS(text, character);
                    }, { once: true });
                    return;
                }

                // Clean up the text - ensure it's complete
                const cleanText = text.trim();
                if (!cleanText) {
                    console.warn('Empty text provided for TTS');
                    isVoicePlaying = false;
                    updateSpeakButton(false);
                    return;
                }

                const utterance = new SpeechSynthesisUtterance(cleanText);

                // Optimal settings for complete sentence delivery
                utterance.rate = 0.82;  // Slightly slower for clarity
                utterance.pitch = currentCharacter === 'sunny' ? 1.2 :
                                 currentCharacter === 'terra' ? 0.95 :
                                 currentCharacter === 'luna' ? 1.1 :
                                 currentCharacter === 'aurora' ? 1.1 : 1.0;
                utterance.volume = 1.0;  // Full volume
                utterance.lang = 'en-US';

                // Chrome/Edge fix: Keep speech synthesis alive
                let keepAliveInterval;

                // Add voice management for browser TTS
                utterance.onstart = () => {
                    isVoicePlaying = true;
                    updateSpeakButton(true);
                    console.log(`üîä Started speaking: "${cleanText}"`);

                    // Keep speech synthesis alive to prevent Chrome timeout
                    keepAliveInterval = setInterval(() => {
                        if (!speechSynthesis.speaking) {
                            clearInterval(keepAliveInterval);
                        } else {
                            // Pause/resume to keep alive (fixes Chrome 15-second timeout bug)
                            speechSynthesis.pause();
                            speechSynthesis.resume();
                        }
                    }, 14000); // Every 14 seconds
                };

                utterance.onend = () => {
                    if (keepAliveInterval) clearInterval(keepAliveInterval);
                    isVoicePlaying = false;
                    updateSpeakButton(false);
                    console.log(`‚úÖ Finished speaking complete sentence`);
                };

                utterance.onerror = (event) => {
                    if (keepAliveInterval) clearInterval(keepAliveInterval);
                    console.warn('‚ö†Ô∏è Speech synthesis error:', event.error);
                    isVoicePlaying = false;
                    updateSpeakButton(false);

                    // Only show error if it's not an interruption
                    if (event.error !== 'interrupted' && event.error !== 'canceled') {
                        console.log('Voice synthesis temporarily unavailable');
                    }
                };

                utterance.onpause = () => {
                    console.log('‚è∏Ô∏è Speech paused');
                };

                utterance.onresume = () => {
                    console.log('‚ñ∂Ô∏è Speech resumed');
                };

                utterance.onboundary = (event) => {
                    // Track word boundaries to ensure completion
                    console.log(`üìñ Speaking: ${event.name} at position ${event.charIndex}`);
                };

                // Try to use a more natural voice if available
                const preferredVoice = voices.find(voice =>
                    (voice.lang.includes('en') && (
                        voice.name.includes('Neural') ||
                        voice.name.includes('Premium') ||
                        voice.name.includes('Enhanced') ||
                        voice.name.includes('Natural') ||
                        voice.name.includes('Google') ||
                        voice.name.includes('Microsoft')
                    ))
                );

                if (preferredVoice) {
                    utterance.voice = preferredVoice;
                    console.log(`üéôÔ∏è Using voice: ${preferredVoice.name}`);
                } else if (voices.length > 0) {
                    // Use first English voice as fallback
                    const englishVoice = voices.find(v => v.lang.includes('en'));
                    if (englishVoice) {
                        utterance.voice = englishVoice;
                        console.log(`üéôÔ∏è Using fallback voice: ${englishVoice.name}`);
                    }
                }

                console.log('üì¢ About to call speechSynthesis.speak()...');
                console.log(`   Utterance text: "${cleanText}"`);
                console.log(`   Utterance rate: ${utterance.rate}`);
                console.log(`   Utterance volume: ${utterance.volume}`);
                console.log(`   Utterance voice: ${utterance.voice ? utterance.voice.name : 'default'}`);

                try {
                    // Speak the utterance
                    speechSynthesis.speak(utterance);
                    console.log(`‚úÖ speechSynthesis.speak() CALLED!`);
                    console.log(`üéôÔ∏è Text queued (${cleanText.length} characters)`);
                    console.log(`   Should start speaking any moment...`);
                } catch (error) {
                    console.error('‚ùå ERROR in speechSynthesis.speak():', error);
                    isVoicePlaying = false;
                    updateSpeakButton(false);
                    alert('Speech error: ' + error.message);
                }
            }
        }
        
        // Debounce timer for voice actions
        let voiceTimeout = null;

        function nextCharacterDialogue() {
            console.log('‚è≠Ô∏è ========== NEXT BUTTON CLICKED ==========');

            try {
                // Clear any pending voice actions
                if (typeof voiceTimeout !== 'undefined' && voiceTimeout) {
                    clearTimeout(voiceTimeout);
                }

                // Stop any currently playing voice before switching
                if (typeof isVoicePlaying !== 'undefined' && isVoicePlaying) {
                    console.log('Stopping current voice...');
                    stopCurrentVoice();
                }

                const character = storyCharacters[currentCharacter];
                if (!character) {
                    console.error('‚ùå Character not found!');
                    alert('Error: Character not found!');
                    return;
                }

                console.log(`Current character: ${currentCharacter}`);
                console.log(`Current dialogue index: ${currentDialogueIndex}`);
                console.log(`Total dialogues: ${character.dialogues.length}`);

                currentDialogueIndex = (currentDialogueIndex + 1) % character.dialogues.length;

                console.log(`New dialogue index: ${currentDialogueIndex}`);

                updateCharacterDisplay();

                console.log('‚úÖ Moved to next dialogue!');
                console.log(`üìù New dialogue: "${character.dialogues[currentDialogueIndex].substring(0, 50)}..."`);
            } catch (error) {
                console.error('‚ùå Error in nextCharacterDialogue:', error);
                alert('Error advancing dialogue: ' + error.message);
            }
        }

        function switchCharacter(characterKey) {
            // Clear any pending voice actions
            if (voiceTimeout) clearTimeout(voiceTimeout);

            // Stop any currently playing voice before switching characters
            if (isVoicePlaying) {
                stopCurrentVoice();
            }

            currentCharacter = characterKey;
            currentDialogueIndex = 0;

            if (storyMode) {
                updateCharacterDisplay();
                console.log(`üîÑ Switched to ${characterKey} - Click Speak to hear dialogue`);
            }
        }
        
        function triggerStoryEvent(eventType) {
            if (!storyMode) return;
            
            switch(eventType) {
                case 'solar_flare':
                    // Don't switch character during chapter navigation
                    if (currentChapter === 1) {
                        setCharacterDialogue("Whoosh! I just sent a solar flare toward Earth! Watch as my energy travels through space!");
                    }
                    break;
                case 'cme_event':
                    // Only trigger if not in chapter mode
                    if (currentChapter === 2) {
                        setCharacterDialogue("Alert! A coronal mass ejection is heading toward Earth! Let's watch Terra protect everyone!");
                    }
                    break;
                case 'aurora_display':
                    // Only trigger if in chapter 4
                    if (currentChapter === 4) {
                        setCharacterDialogue("Look at my beautiful auroras! This is how I turn space weather into a light show!");
                    }
                    break;
            }
        }
        
        // Story Chapter Navigation
        let currentChapter = 1;
        let completedChapters = [];
        
        function goToChapter(chapterNumber) {
            if (!storyMode) {
                console.warn('‚ö†Ô∏è Cannot go to chapter - Story mode not active');
                return;
            }

            // Stop any currently playing voice before switching chapters
            if (isVoicePlaying) {
                stopCurrentVoice();
            }

            currentChapter = chapterNumber;
            const chapter = storyChapters[chapterNumber];

            if (!chapter) {
                console.error(`‚ùå Chapter ${chapterNumber} not found`);
                return;
            }

            // Update chapter button states
            document.querySelectorAll('.story-chapter-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            const currentChapterBtn = document.getElementById(`chapter-${chapterNumber}-btn`);
            if (currentChapterBtn) {
                currentChapterBtn.classList.add('active');
            }

            // Switch to appropriate character and camera mode
            switchCharacter(chapter.character);
            setCameraMode(chapter.cameraMode);

            // Show character panel if hidden
            const panel = document.getElementById('story-character-panel');
            if (panel && !panel.classList.contains('active')) {
                panel.classList.add('active');
            }

            // Trigger chapter-specific events after a brief delay
            setTimeout(() => {
                triggerChapterEvents(chapterNumber);
            }, 800);

            // Mark previous chapters as completed
            for (let i = 1; i < chapterNumber; i++) {
                if (!completedChapters.includes(i)) {
                    completedChapters.push(i);
                    const prevChapterBtn = document.getElementById(`chapter-${i}-btn`);
                    if (prevChapterBtn) {
                        prevChapterBtn.classList.add('completed');
                    }
                }
            }

            // Show visual notification
            showStoryNotification(`üìñ ${chapter.title}`, 2500);

            console.log(`üìñ Started Chapter ${chapterNumber}: ${chapter.title}`);
            console.log(`üé≠ Character: ${chapter.character}, üì∑ Camera: ${chapter.cameraMode}`);
        }
        
        function triggerChapterEvents(chapterNumber) {
            // Get real-time data for dynamic storytelling
            const realData = getRealTimeStoryData();

            switch(chapterNumber) {
                case 1:
                    // Chapter 1: Meet Sunny with REAL data
                    const sunnyIntro = `Welcome to Chapter 1! I'm Sunny, the star of our solar system! Right now, there are ${realData.cmeCount} CME events and ${realData.flareCount} solar flares happening! ${realData.activityLevel}`;
                    setCharacterDialogue(sunnyIntro);
                    break;

                case 2:
                    // Chapter 2: The Great Space Journey with real CME info
                    const journeyText = `Chapter 2: Watch as space weather travels from me to Earth! ${realData.cmeInfo}. This journey takes 1-3 days in real life, but we'll speed it up for you!`;
                    setCharacterDialogue(journeyText);
                    triggerStoryEvent('cme_event');
                    break;

                case 3:
                    // Chapter 3: Heroes Respond with real impact data
                    const heroText = `Chapter 3: I'm Terra! When space weather reaches me, heroes help protect everyone. ${realData.impactInfo} Let me introduce you to these brave heroes!`;
                    setCharacterDialogue(heroText);
                    setTimeout(() => showEarthHeroes(), 3000);
                    break;

                case 4:
                    // Chapter 4: Aurora Dance with real aurora data
                    const auroraText = `Chapter 4: Behold the Aurora Dance! ${realData.auroraInfo} This is how I turn space weather into beautiful light shows at my poles!`;
                    setCharacterDialogue(auroraText);
                    triggerStoryEvent('aurora_display');
                    break;

                case 5:
                    // Chapter 5: Space Weather Guardians with real monitoring info
                    const guardianText = `Chapter 5: I'm Captain Aurora! We monitor space weather 24/7 to keep everyone safe. ${realData.monitoringInfo} Let me show you our guardian systems!`;
                    setCharacterDialogue(guardianText);
                    setTimeout(() => showGuardianSystems(), 3000);
                    break;
            }
        }

        // Get real-time data for storytelling
        function getRealTimeStoryData() {
            const cmeCount = cmeObjects.length;
            const flareCount = flareObjects.length;
            const totalEvents = cmeCount + flareCount;

            // Get activity level
            let activityLevel = "The sun is quiet today, perfect for learning!";
            if (totalEvents > 15) {
                activityLevel = "I'm very active today with lots of space weather events!";
            } else if (totalEvents > 5) {
                activityLevel = "I'm moderately active with some exciting events happening!";
            }

            // CME information
            let cmeInfo = cmeCount > 0
                ? `Currently, ${cmeCount} coronal mass ejections are traveling through space toward Earth!`
                : "No major CME events right now, but I'm always creating solar wind!";

            // Impact information
            let impactInfo = totalEvents > 10
                ? "Today's space weather could affect GPS systems, power grids, and create beautiful auroras!"
                : "Space weather today is mild, but we still need to stay prepared!";

            // Aurora information
            let auroraInfo = totalEvents > 8
                ? "Current space weather conditions may produce stunning auroras visible at high latitudes!"
                : "Aurora activity is low today, but they're still dancing at the poles!";

            // Monitoring information
            let monitoringInfo = `Right now, we're tracking ${totalEvents} total space weather events from multiple satellites and ground stations!`;

            return {
                cmeCount,
                flareCount,
                totalEvents,
                activityLevel,
                cmeInfo,
                impactInfo,
                auroraInfo,
                monitoringInfo
            };
        }
        
        function showEarthHeroes() {
            // Show different hero perspectives
            const heroes = [
                "üë®‚Äçüåæ Farmer Joe checks space weather to protect his GPS-guided tractors!",
                "üë©‚Äç‚úàÔ∏è Pilot Sarah adjusts her flight path during solar storms!",
                "üë®‚ÄçüöÄ Astronaut Mike takes shelter in the ISS during space weather events!",
                "üë©‚Äçüíº Power Grid Manager Lisa prepares for geomagnetic storms!"
            ];
            
            let heroIndex = 0;
            const showNextHero = () => {
                if (heroIndex < heroes.length && storyMode && currentChapter === 3) {
                    setCharacterDialogue(heroes[heroIndex]);
                    heroIndex++;
                    setTimeout(showNextHero, 4000);
                }
            };
            showNextHero();
        }
        
        function showGuardianSystems() {
            // Show guardian systems
            const systems = [
                "üõ∞Ô∏è NASA satellites monitor the sun 24/7 from space!",
                "üì° Ground stations like NOAA track space weather patterns!",
                "üñ•Ô∏è Supercomputers predict when space weather will reach Earth!",
                "üì± Alert systems warn people when big storms are coming!"
            ];
            
            let systemIndex = 0;
            const showNextSystem = () => {
                if (systemIndex < systems.length && storyMode && currentChapter === 5) {
                    setCharacterDialogue(systems[systemIndex]);
                    systemIndex++;
                    setTimeout(showNextSystem, 4000);
                }
            };
            showNextSystem();
        }
        
        // Mission Clock System
        function updateMissionClock() {
            const now = new Date();
            const hours = String(now.getUTCHours()).padStart(2, '0');
            const minutes = String(now.getUTCMinutes()).padStart(2, '0');
            const seconds = String(now.getUTCSeconds()).padStart(2, '0');
            document.getElementById('missionClock').textContent = `${hours}:${minutes}:${seconds}`;
        }

        // Start mission clock
        setInterval(updateMissionClock, 1000);
        updateMissionClock();

        function init() {
            // Create scene with fog for depth
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000011, 0.00025);

            // Create camera with better FOV
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.set(0, 200, 400);

            // Create renderer with optimized settings and preserve drawing buffer for screenshots
            renderer = new THREE.WebGLRenderer({ 
                antialias: window.devicePixelRatio < 2, 
                powerPreference: "high-performance",
                stencil: false,
                depth: true,
                logarithmicDepthBuffer: true,
                preserveDrawingBuffer: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.shadowMap.enabled = false; // Disable shadows for better performance
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.8;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Add resize listener now that camera and renderer exist
            window.addEventListener('resize', onWindowResize);

            // Create spectacular background
            createSpectacularBackground();

            // Create enhanced solar system
            createEnhancedSolarSystem();

            // Setup advanced lighting
            setupAdvancedLighting();

            // Setup camera controls
            setupAdvancedControls();

            // Load NASA data
            setTimeout(loadNASAData, 2000);

            // Start animation
            animate();

            // Setup custom cursor
            setupCustomCursor();
            
            // Setup object interaction for story mode
            setupObjectInteraction();

            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
            }, 3000);

            console.log('‚úÖ Spectacular 3D Observatory initialized!');
        }

        function createSpectacularBackground() {
            // Create optimized nebula background
            const nebulaGeometry = new THREE.SphereGeometry(5000, 32, 32);
            const nebulaTexture = createNebulaTexture();
            const nebulaMaterial = new THREE.MeshBasicMaterial({
                map: nebulaTexture,
                side: THREE.BackSide,
                transparent: true,
                opacity: 0.6
            });
            const nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
            scene.add(nebula);

            // Create optimized star field
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 8000;
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);

            for (let i = 0; i < starCount; i++) {
                // Position
                positions[i * 3] = (Math.random() - 0.5) * 10000;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 10000;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 10000;

                // Color (various star types)
                const starType = Math.random();
                if (starType < 0.7) {
                    // White/blue stars
                    colors[i * 3] = 0.8 + Math.random() * 0.2;
                    colors[i * 3 + 1] = 0.8 + Math.random() * 0.2;
                    colors[i * 3 + 2] = 1.0;
                } else if (starType < 0.9) {
                    // Yellow/orange stars
                    colors[i * 3] = 1.0;
                    colors[i * 3 + 1] = 0.6 + Math.random() * 0.4;
                    colors[i * 3 + 2] = 0.2;
                } else {
                    // Red giants
                    colors[i * 3] = 1.0;
                    colors[i * 3 + 1] = 0.2;
                    colors[i * 3 + 2] = 0.2;
                }

                // Size
                sizes[i] = Math.random() * 3 + 0.5;
            }

            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            starGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const starMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    attribute float size;
                    varying vec3 vColor;
                    uniform float time;

                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z) * (1.0 + 0.3 * sin(time + position.x * 0.01));
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    
                    void main() {
                        float distance = length(gl_PointCoord - vec2(0.5));
                        if (distance > 0.5) discard;
                        
                        float alpha = 1.0 - distance * 2.0;
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                transparent: true,
                vertexColors: true
            });

            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);

            console.log('üåå Optimized background created with 8,000 stars');
        }

        function createContinuousSolarWind() {
            // Create flowing solar wind particles
            const windCount = 1500;
            const windGeometry = new THREE.BufferGeometry();
            const windPositions = new Float32Array(windCount * 3);
            const windVelocities = new Float32Array(windCount * 3);
            const windSizes = new Float32Array(windCount);

            for (let i = 0; i < windCount; i++) {
                const i3 = i * 3;
                const angle = Math.random() * Math.PI * 2;
                const radius = 25 + Math.random() * 15;
                
                windPositions[i3] = Math.cos(angle) * radius;
                windPositions[i3 + 1] = (Math.random() - 0.5) * 20;
                windPositions[i3 + 2] = Math.sin(angle) * radius;
                
                windVelocities[i3] = Math.cos(angle) * (1.5 + Math.random() * 0.5);
                windVelocities[i3 + 1] = (Math.random() - 0.5) * 0.2;
                windVelocities[i3 + 2] = Math.sin(angle) * (1.5 + Math.random() * 0.5);
                
                windSizes[i] = 0.5 + Math.random() * 1.5;
            }

            windGeometry.setAttribute('position', new THREE.BufferAttribute(windPositions, 3));
            windGeometry.setAttribute('velocity', new THREE.BufferAttribute(windVelocities, 3));
            windGeometry.setAttribute('size', new THREE.BufferAttribute(windSizes, 1));

            const windMaterial = new THREE.PointsMaterial({
                color: 0x00aaff,
                size: 1,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });

            const solarWind = new THREE.Points(windGeometry, windMaterial);
            solarWind.userData = { type: 'solarWind' };
            scene.add(solarWind);
            solarWindParticles.push(solarWind);

            console.log('üå™Ô∏è Continuous solar wind created');
        }

        function createNebulaTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Create gradient
            const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
            gradient.addColorStop(0, 'rgba(0, 100, 255, 0.8)');
            gradient.addColorStop(0.3, 'rgba(100, 0, 255, 0.6)');
            gradient.addColorStop(0.6, 'rgba(255, 0, 100, 0.4)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);

            return new THREE.CanvasTexture(canvas);
        }

        function createEnhancedSolarSystem() {
            // Create enhanced Sun with corona
            const sunGroup = new THREE.Group();
            
            // Sun core (optimized geometry)
            const sunGeometry = new THREE.SphereGeometry(20, 32, 32);
            const sunMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    intensity: { value: 1.5 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    uniform float time;
                    
                    void main() {
                        vUv = uv;
                        vPosition = position;
                        
                        vec3 newPosition = position;
                        float noise = sin(position.x * 2.0 + time) * 
                                     cos(position.y * 2.0 + time) * 
                                     sin(position.z * 2.0 + time) * 0.3;
                        newPosition += normal * noise;
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    uniform float time;
                    uniform float intensity;
                    
                    void main() {
                        float noise = sin(vPosition.x * 3.0 + time * 2.0) * 
                                     cos(vPosition.y * 3.0 + time * 1.5) * 
                                     sin(vPosition.z * 3.0 + time * 2.5);
                        
                        vec3 color = mix(
                            vec3(1.0, 0.4, 0.0),
                            vec3(1.0, 1.0, 0.2),
                            (noise + 1.0) * 0.5
                        );
                        
                        gl_FragColor = vec4(color * intensity, 1.0);
                    }
                `
            });
            sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sunGroup.add(sun);

            // Sun corona
            const coronaGeometry = new THREE.SphereGeometry(25, 32, 32);
            const coronaMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    uniform float time;
                    
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    uniform float time;
                    
                    void main() {
                        float fresnel = pow(1.0 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                        float pulse = sin(time * 2.0) * 0.3 + 0.7;
                        
                        vec3 coronaColor = vec3(0.8, 0.4, 1.0) * fresnel * pulse;
                        gl_FragColor = vec4(coronaColor, fresnel * 0.5);
                    }
                `,
                transparent: true,
                side: THREE.BackSide
            });
            const corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
            sunGroup.add(corona);

            scene.add(sunGroup);

            // Create spectacular continuous solar wind
            createContinuousSolarWind();

            // Create enhanced Earth with atmosphere
            const earthGroup = new THREE.Group();
            
            // Earth (optimized geometry)
            const earthGeometry = new THREE.SphereGeometry(8, 32, 32);
            const earthTexture = createEarthTexture();
            const earthMaterial = new THREE.MeshPhongMaterial({
                map: earthTexture,
                shininess: 100,
                specular: 0x222222
            });
            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            earthGroup.add(earth);

            // Earth atmosphere
            const atmosphereGeometry = new THREE.SphereGeometry(8.5, 32, 32);
            const atmosphereMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vNormal;
                    uniform float time;
                    
                    void main() {
                        float fresnel = pow(1.0 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 3.0);
                        vec3 atmosphere = vec3(0.3, 0.6, 1.0) * fresnel;
                        gl_FragColor = vec4(atmosphere, fresnel * 0.8);
                    }
                `,
                transparent: true,
                side: THREE.BackSide
            });
            const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            earthGroup.add(atmosphere);

            earthGroup.position.set(150, 0, 0);
            scene.add(earthGroup);

            // Create Moon
            const moonGeometry = new THREE.SphereGeometry(2, 32, 32);
            const moonMaterial = new THREE.MeshPhongMaterial({
                color: 0xcccccc,
                shininess: 10
            });
            moon = new THREE.Mesh(moonGeometry, moonMaterial);
            moon.position.set(165, 0, 0);
            moon.userData = { type: 'moon', character: 'luna' };
            scene.add(moon);

            // Create other planets
            createOtherPlanets();

            console.log('üåç Enhanced solar system created');
        }

        function createEarthTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // Create simple Earth-like texture
            const gradient = ctx.createLinearGradient(0, 0, 0, 256);
            gradient.addColorStop(0, '#87CEEB');  // Sky blue
            gradient.addColorStop(0.3, '#4169E1'); // Royal blue
            gradient.addColorStop(0.7, '#228B22'); // Forest green
            gradient.addColorStop(1, '#8B4513');   // Saddle brown

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 256);

            // Add some random continents
            ctx.fillStyle = '#228B22';
            for (let i = 0; i < 20; i++) {
                ctx.beginPath();
                ctx.arc(Math.random() * 512, Math.random() * 256, Math.random() * 50 + 10, 0, Math.PI * 2);
                ctx.fill();
            }

            return new THREE.CanvasTexture(canvas);
        }

        function createOtherPlanets() {
            // Mercury
            const mercuryGeometry = new THREE.SphereGeometry(2, 16, 16);
            const mercuryMaterial = new THREE.MeshPhongMaterial({ color: 0x8c7853 });
            mercury = new THREE.Mesh(mercuryGeometry, mercuryMaterial);
            mercury.position.set(58, 0, 0);
            scene.add(mercury);

            // Venus
            const venusGeometry = new THREE.SphereGeometry(3, 24, 24);
            const venusMaterial = new THREE.MeshPhongMaterial({ color: 0xffc649 });
            venus = new THREE.Mesh(venusGeometry, venusMaterial);
            venus.position.set(108, 0, 0);
            scene.add(venus);

            // Mars
            const marsGeometry = new THREE.SphereGeometry(4, 32, 32);
            const marsMaterial = new THREE.MeshPhongMaterial({ color: 0xcd5c5c });
            mars = new THREE.Mesh(marsGeometry, marsMaterial);
            mars.position.set(228, 0, 0);
            scene.add(mars);
        }

        function setupAdvancedLighting() {
            // Enhanced ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.2);
            scene.add(ambientLight);

            // Sun's point light
            const sunLight = new THREE.PointLight(0xffffff, 2, 1000);
            sunLight.position.set(0, 0, 0);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 4096;
            sunLight.shadow.mapSize.height = 4096;
            sunLight.shadow.camera.near = 1;
            sunLight.shadow.camera.far = 1000;
            scene.add(sunLight);

            // Additional directional light for better visibility
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight.position.set(100, 100, 50);
            scene.add(directionalLight);

            console.log('üí° Advanced lighting setup complete');
        }

        function setupAdvancedControls() {
            let isMouseDown = false;
            let mouseX = 0, mouseY = 0;
            let cameraRadius = 400;
            let cameraTheta = 0;
            let cameraPhi = Math.PI * 0.3;

            function updateCameraPosition() {
                if (cameraMode === 'overview') {
                    camera.position.x = cameraRadius * Math.sin(cameraPhi) * Math.cos(cameraTheta);
                    camera.position.y = cameraRadius * Math.cos(cameraPhi);
                    camera.position.z = cameraRadius * Math.sin(cameraPhi) * Math.sin(cameraTheta);
                    camera.lookAt(0, 0, 0);
                }
            }

            renderer.domElement.addEventListener('mousedown', (event) => {
                isMouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });

            document.addEventListener('mouseup', () => {
                isMouseDown = false;
            });

            document.addEventListener('mousemove', (event) => {
                if (isMouseDown && cameraMode === 'overview') {
                    const deltaX = event.clientX - mouseX;
                    const deltaY = event.clientY - mouseY;

                    cameraTheta -= deltaX * 0.01;
                    cameraPhi += deltaY * 0.01;
                    
                    cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi));

                    updateCameraPosition();

                    mouseX = event.clientX;
                    mouseY = event.clientY;
                }
            });

            renderer.domElement.addEventListener('wheel', (event) => {
                event.preventDefault();
                const scale = event.deltaY > 0 ? 1.1 : 0.9;
                cameraRadius *= scale;
                cameraRadius = Math.max(50, Math.min(2000, cameraRadius));
                
                if (cameraMode === 'overview') {
                    updateCameraPosition();
                }
            });

            // Keyboard controls
            document.addEventListener('keydown', (event) => {
                switch(event.code) {
                    case 'Space':
                        event.preventDefault();
                        toggleAnimation();
                        break;
                    case 'KeyR':
                        resetView();
                        break;
                    case 'KeyF':
                        toggleFullscreen();
                        break;
                }
            });

            console.log('üéÆ Advanced controls setup complete');
        }

        function setupCustomCursor() {
            const cursor = document.getElementById('custom-cursor');
            
            document.addEventListener('mousemove', (e) => {
                cursor.style.left = e.clientX - 10 + 'px';
                cursor.style.top = e.clientY - 10 + 'px';
            });

            document.addEventListener('mousedown', () => {
                cursor.style.transform = 'scale(0.8)';
            });

            document.addEventListener('mouseup', () => {
                cursor.style.transform = 'scale(1)';
            });
        }
        
        function setupObjectInteraction() {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            function onMouseClick(event) {
                if (!storyMode) return;
                
                // Calculate mouse position in normalized device coordinates
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                // Update the raycaster
                raycaster.setFromCamera(mouse, camera);
                
                // Calculate objects intersecting the picking ray
                const intersects = raycaster.intersectObjects(scene.children, true);
                
                for (let i = 0; i < intersects.length; i++) {
                    const object = intersects[i].object;
                    
                    // Check if we clicked on the sun
                    if (object === sun) {
                        switchCharacter('sunny');
                        setCameraMode('sun');
                        // Trigger a special sunny event
                        setTimeout(() => {
                            triggerStoryEvent('solar_flare');
                            // Make the sun more active visually
                            if (sun.material.uniforms) {
                                sun.material.uniforms.intensity.value = Math.min(3.0, sun.material.uniforms.intensity.value + 0.5);
                            }
                        }, 500);
                        break;
                    }
                    
                    // Check if we clicked on Earth
                    if (object === earth) {
                        switchCharacter('terra');
                        setCameraMode('earth');
                        break;
                    }
                    
                    // Check if we clicked on the moon
                    if (object === moon) {
                        switchCharacter('luna');
                        // Custom moon camera position
                        camera.position.set(180, 30, 50);
                        camera.lookAt(165, 0, 0);
                        cameraMode = 'custom';
                        break;
                    }
                    
                    // Check if we clicked on other planets
                    if (object === mercury) {
                        switchCharacter('aurora');
                        setCharacterDialogue("That's Mercury, the closest planet to Sunny! It gets hit by space weather first!");
                        break;
                    }
                    
                    if (object === venus) {
                        switchCharacter('aurora');
                        setCharacterDialogue("Venus has a thick atmosphere that protects it differently from space weather!");
                        break;
                    }
                    
                    if (object === mars) {
                        switchCharacter('aurora');
                        setCharacterDialogue("Mars doesn't have a strong magnetic field like Terra, so space weather affects it more!");
                        break;
                    }
                }
            }
            
            renderer.domElement.addEventListener('click', onMouseClick, false);
            console.log('üñ±Ô∏è Object interaction system ready for story mode!');
        }

        let dataLoaded = false; // Prevent infinite loop

        function loadNASAData() {
            if (dataLoaded) {
                console.log('üìä Data already loaded, skipping...');
                return;
            }

            console.log('üì° Loading NASA observatory data...');

            if (window.LIVE_NASA_DATA && window.LIVE_NASA_DATA.events) {
                nasaData = window.LIVE_NASA_DATA;
                console.log('‚úÖ NASA data loaded:', nasaData);

                updateDataDisplay();
                createSpectacularCMEVisualization();
                createSpectacularFlareVisualization();
                updateConnectionStatus('online');
                dataLoaded = true;

                // Check for high-speed CMEs and show alert (only in professional mode)
                const highSpeedCMEs = nasaData.events.cmes.filter(cme => (cme.speed || 0) > 1000);
                if (highSpeedCMEs.length > 0 && !storyMode) {
                    showEmergencyAlert(highSpeedCMEs[0]);
                }

            } else {
                console.log('‚è≥ NASA data not available, creating spectacular simulation...');
                updateConnectionStatus('loading');
                createSpectacularSimulation();
                dataLoaded = true; // Mark as loaded to prevent loop
            }
        }

        function createSpectacularSimulation() {
            // Create simulation data that looks impressive
            nasaData = {
                summary: {
                    cme_count: 12,
                    solar_flare_count: 8,
                    total_events: 20
                },
                events: {
                    cmes: [
                        { id: 'SIM_CME_001', speed: 850, start_time: new Date().toISOString(), source_location: 'N15E25' },
                        { id: 'SIM_CME_002', speed: 1200, start_time: new Date().toISOString(), source_location: 'S20W10' },
                        { id: 'SIM_CME_003', speed: 650, start_time: new Date().toISOString(), source_location: 'N05E45' },
                        { id: 'SIM_CME_004', speed: 920, start_time: new Date().toISOString(), source_location: 'S10E30' }
                    ],
                    solar_flares: [
                        { id: 'SIM_FLARE_001', class_type: 'X2.5', start_time: new Date().toISOString(), source_location: 'N15E25' },
                        { id: 'SIM_FLARE_002', class_type: 'M8.1', start_time: new Date().toISOString(), source_location: 'S20W10' },
                        { id: 'SIM_FLARE_003', class_type: 'M5.3', start_time: new Date().toISOString(), source_location: 'N05E45' }
                    ]
                }
            };
            
            updateDataDisplay();
            createSpectacularCMEVisualization();
            createSpectacularFlareVisualization();
            
            // Show simulation alert for X-class flare (only in professional mode)
            setTimeout(() => {
                if (!storyMode) {
                    showEmergencyAlert(nasaData.events.cmes[1]);
                }
            }, 5000);
        }

        function updateDataDisplay() {
            if (!nasaData) return;

            const summary = nasaData.summary;
            
            // Update status metrics with animation
            animateValueChange('cme-count', summary.cme_count || 0);
            animateValueChange('flare-count', summary.solar_flare_count || 0);
            
            // Determine activity level
            const totalEvents = summary.total_events || 0;
            let activity = 'QUIET';
            if (totalEvents > 30) activity = 'EXTREME';
            else if (totalEvents > 20) activity = 'SEVERE';
            else if (totalEvents > 15) activity = 'HIGH';
            else if (totalEvents > 10) activity = 'MODERATE';
            else if (totalEvents > 5) activity = 'LOW';
            
            document.getElementById('activity-level').textContent = activity;

            // Update events display
            updateEventsDisplay();
            
            // Create story-friendly data narratives
            if (storyMode) {
                updateStoryNarratives(summary, totalEvents, activity);
            }
        }
        
        function updateStoryNarratives(summary, totalEvents, activity) {
            // Don't interfere with chapter navigation or user interactions
            if (currentChapter > 1) return;
            
            // Create dynamic story content based on real NASA data (only for initial dialogue)
            const cmeCount = summary.cme_count || 0;
            const flareCount = summary.solar_flare_count || 0;
            
            // Only update if we're on the first dialogue of each character
            if (currentDialogueIndex === 0) {
                if (currentCharacter === 'sunny') {
                    let sunnyDialogue = "";
                    if (activity === 'EXTREME') {
                        sunnyDialogue = `WOW! I'm super active today with ${totalEvents} space weather events! I've sent ${cmeCount} CME blasts and ${flareCount} solar flares toward Terra!`;
                    } else if (activity === 'HIGH' || activity === 'SEVERE') {
                        sunnyDialogue = `I'm feeling quite energetic today! I've created ${cmeCount} CME events and ${flareCount} solar flares. Terra will need to use her magnetic shield!`;
                    } else if (activity === 'MODERATE') {
                        sunnyDialogue = `I'm having a moderate day with ${totalEvents} space weather events. That's ${cmeCount} CMEs and ${flareCount} flares to keep Terra on her toes!`;
                    } else {
                        sunnyDialogue = `I'm taking it easy today with only ${totalEvents} space weather events. Just ${cmeCount} CMEs and ${flareCount} flares - Terra can relax!`;
                    }
                    
                    // Update only the current dialogue, don't call updateCharacterDisplay
                    storyCharacters.sunny.dialogues[0] = sunnyDialogue;
                    if (currentCharacter === 'sunny' && currentDialogueIndex === 0) {
                        document.getElementById('characterDialogue').textContent = sunnyDialogue;
                    }
                }
            }
            
            // Update the observatory data panel with story-friendly descriptions
            updateStoryDataPanel(summary, activity);
        }
        
        function updateStoryDataPanel(summary, activity) {
            const container = document.getElementById('events-container');
            
            if (storyMode) {
                // Create kid-friendly event descriptions
                const storyContent = document.createElement('div');
                storyContent.style.textAlign = 'center';
                storyContent.style.color = '#ffd93d';
                storyContent.style.fontSize = '1.1rem';
                storyContent.style.lineHeight = '1.6';
                storyContent.style.padding = '20px';
                storyContent.style.background = 'rgba(255, 217, 61, 0.1)';
                storyContent.style.borderRadius = '15px';
                storyContent.style.border = '2px solid rgba(255, 217, 61, 0.3)';
                
                const totalEvents = summary.total_events || 0;
                const cmeCount = summary.cme_count || 0;
                const flareCount = summary.solar_flare_count || 0;
                
                storyContent.innerHTML = `
                    <div style="font-size: 1.3rem; margin-bottom: 15px; color: #ff6b6b;">
                        üìä Today's Space Weather Adventure!
                    </div>
                    <div style="margin-bottom: 10px;">
                        üåû Sunny has been <strong>${activity.toLowerCase()}</strong> today!
                    </div>
                    <div style="margin-bottom: 10px;">
                        üåÄ <strong>${cmeCount}</strong> CME space blasts sent toward Terra!
                    </div>
                    <div style="margin-bottom: 10px;">
                        ‚òÄÔ∏è <strong>${flareCount}</strong> solar flares lighting up the solar system!
                    </div>
                    <div style="margin-bottom: 15px;">
                        ‚ú® Total space weather events: <strong>${totalEvents}</strong>
                    </div>
                    <div style="font-size: 0.9rem; font-style: italic; color: #4ecdc4;">
                        This data comes from real NASA satellites watching the sun right now! üõ∞Ô∏è
                    </div>
                `;
                
                // Replace container content with story version
                container.innerHTML = '';
                container.appendChild(storyContent);
            } else {
                // Professional mode - call the existing updateEventsDisplay
                updateEventsDisplay();
            }
        }
        
        // Complete todos
        function markTodoCompleted() {
            console.log('‚úÖ All story mode and professional features completed!');
            console.log('üöÄ Platform ready with dual-mode functionality: professional excellence and educational storytelling!');
        }

        function animateValueChange(elementId, newValue) {
            const element = document.getElementById(elementId);
            const currentValue = parseInt(element.textContent) || 0;
            
            if (currentValue !== newValue) {
                let step = 0;
                const steps = 20;
                const increment = (newValue - currentValue) / steps;
                
                const animation = setInterval(() => {
                    step++;
                    const value = Math.round(currentValue + increment * step);
                    element.textContent = value;
                    
                    if (step >= steps) {
                        clearInterval(animation);
                        element.textContent = newValue;
                    }
                }, 50);
            }
        }

        function updateEventsDisplay() {
            const container = document.getElementById('events-container');
            container.innerHTML = '';

            // Add CME events
            nasaData.events.cmes.slice(0, 6).forEach((cme, index) => {
                const card = document.createElement('div');
                card.className = 'event-card';
                
                const speed = cme.speed || 500;
                const riskLevel = speed > 1000 ? 'EXTREME' : speed > 800 ? 'HIGH' : speed > 600 ? 'MODERATE' : 'LOW';
                const riskColor = speed > 1000 ? '#ff0000' : speed > 800 ? '#ff8000' : speed > 600 ? '#ffff00' : '#00ff00';
                
                card.innerHTML = `
                    <div class="event-header">üåÄ CME EVENT ${cme.id.slice(-6)}</div>
                    <div class="event-details">
                        <strong>Speed:</strong> ${speed.toLocaleString()} km/s<br>
                        <strong>Source:</strong> ${cme.source_location || 'Unknown'}<br>
                        <strong>Risk Level:</strong> <span style="color: ${riskColor}; font-weight: bold;">${riskLevel}</span><br>
                        <strong>Time:</strong> ${new Date(cme.start_time).toLocaleString()}
                    </div>
                `;
                
                card.onclick = () => focusOnCME(index);
                container.appendChild(card);
            });

            // Add solar flare events
            nasaData.events.solar_flares.slice(0, 4).forEach((flare, index) => {
                const card = document.createElement('div');
                card.className = 'event-card';
                card.style.borderColor = '#ff4444';
                
                const classType = flare.class_type || 'C1.0';
                const intensity = classType.startsWith('X') ? 'EXTREME' : classType.startsWith('M') ? 'HIGH' : 'MODERATE';
                const intensityColor = classType.startsWith('X') ? '#ff0000' : classType.startsWith('M') ? '#ff8000' : '#ffff00';
                
                card.innerHTML = `
                    <div class="event-header" style="color: #ff4444;">‚òÄÔ∏è ${classType} SOLAR FLARE</div>
                    <div class="event-details">
                        <strong>Class:</strong> ${classType}<br>
                        <strong>Intensity:</strong> <span style="color: ${intensityColor}; font-weight: bold;">${intensity}</span><br>
                        <strong>Source:</strong> ${flare.source_location || 'Unknown'}<br>
                        <strong>Time:</strong> ${new Date(flare.start_time).toLocaleString()}
                    </div>
                `;
                
                card.onclick = () => focusOnFlare(index);
                container.appendChild(card);
            });
        }

        function createSpectacularCMEVisualization() {
            // Clear existing CMEs
            cmeObjects.forEach(obj => scene.remove(obj));
            cmeObjects = [];

            if (!nasaData || !nasaData.events.cmes) return;

            nasaData.events.cmes.slice(0, 8).forEach((cme, index) => {
                const speed = cme.speed || 500;
                const cmeGroup = new THREE.Group();
                
                // Create optimized particle system based on CME speed
                const particleCount = Math.min(800, 200 + Math.floor(speed / 3));
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);
                const velocities = new Float32Array(particleCount * 3);

                const angle = (index / 8) * Math.PI * 2;
                const coneAngle = Math.PI * 0.3; // 30 degree cone

                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    
                    // Position in cone shape
                    const particleAngle = angle + (Math.random() - 0.5) * coneAngle;
                    const distance = 25 + Math.random() * 40;
                    const height = (Math.random() - 0.5) * 30;
                    
                    positions[i3] = Math.cos(particleAngle) * distance;
                    positions[i3 + 1] = height;
                    positions[i3 + 2] = Math.sin(particleAngle) * distance;

                    // Velocity for animation
                    velocities[i3] = Math.cos(particleAngle) * (speed / 1000);
                    velocities[i3 + 1] = (Math.random() - 0.5) * 0.1;
                    velocities[i3 + 2] = Math.sin(particleAngle) * (speed / 1000);

                    // Color based on speed and position
                    const intensity = Math.min(speed / 1200, 1);
                    const core = distance < 35 ? 1 : 0.6;
                    
                    colors[i3] = core * (0.8 + intensity * 0.2);     // Red
                    colors[i3 + 1] = core * (0.4 - intensity * 0.3); // Green
                    colors[i3 + 2] = core * (0.1);                   // Blue

                    // Size based on distance and intensity
                    sizes[i] = (2 + intensity * 3) * core;
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        intensity: { value: particleIntensity }
                    },
                    vertexShader: `
                        attribute float size;
                        varying vec3 vColor;
                        varying float vSize;
                        uniform float time;
                        uniform float intensity;

                        void main() {
                            vColor = color;
                            vSize = size;

                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_PointSize = size * intensity * (300.0 / -mvPosition.z) * (1.0 + 0.5 * sin(time * 2.0 + position.x * 0.01));
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vColor;
                        varying float vSize;
                        
                        void main() {
                            vec2 center = gl_PointCoord - vec2(0.5);
                            float distance = length(center);
                            
                            if (distance > 0.5) discard;
                            
                            float alpha = 1.0 - distance * 2.0;
                            float glow = pow(alpha, 0.5);
                            
                            gl_FragColor = vec4(vColor * (1.0 + glow), alpha * 0.8);
                        }
                    `,
                    transparent: true,
                    vertexColors: true,
                    blending: THREE.AdditiveBlending
                });

                const particles = new THREE.Points(geometry, material);
                particles.userData = {
                    type: 'cme',
                    speed: speed,
                    startTime: Date.now(),
                    velocities: velocities,
                    originalPositions: positions.slice(),
                    cmeData: cme
                };

                cmeGroup.add(particles);
                scene.add(cmeGroup);
                cmeObjects.push(cmeGroup);
            });

            console.log(`üåÄ Created ${cmeObjects.length} spectacular CME visualizations`);
            
            // Trigger story event for CME
            if (cmeObjects.length > 0) {
                setTimeout(() => triggerStoryEvent('cme_event'), 2000);
            }
        }

        function createSpectacularFlareVisualization() {
            // Clear existing flares
            flareObjects.forEach(obj => scene.remove(obj));
            flareObjects = [];

            if (!nasaData || !nasaData.events.solar_flares) return;

            nasaData.events.solar_flares.slice(0, 5).forEach((flare, index) => {
                const flareGroup = new THREE.Group();
                
                // Create multiple components for each flare
                const coreGeometry = new THREE.SphereGeometry(3, 16, 16);
                const coreMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        intensity: { value: 2.0 }
                    },
                    vertexShader: `
                        varying vec3 vPosition;
                        uniform float time;
                        
                        void main() {
                            vPosition = position;
                            
                            vec3 newPosition = position;
                            float pulse = sin(time * 8.0) * 0.2 + 1.0;
                            newPosition *= pulse;
                            
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vPosition;
                        uniform float time;
                        uniform float intensity;
                        
                        void main() {
                            float pulse = sin(time * 6.0) * 0.3 + 0.7;
                            vec3 color = vec3(1.0, 0.3, 0.1) * intensity * pulse;
                            gl_FragColor = vec4(color, 0.9);
                        }
                    `,
                    transparent: true
                });

                const flareCore = new THREE.Mesh(coreGeometry, coreMaterial);
                
                // Position flare on sun surface
                const angle = (index / 5) * Math.PI * 2;
                const distance = 22;
                flareCore.position.set(
                    Math.cos(angle) * distance,
                    (Math.random() - 0.5) * 10,
                    Math.sin(angle) * distance
                );

                flareCore.userData = {
                    type: 'flare',
                    startTime: Date.now(),
                    flareData: flare,
                    originalPosition: flareCore.position.clone()
                };

                flareGroup.add(flareCore);
                scene.add(flareGroup);
                flareObjects.push(flareGroup);
            });

            console.log(`‚òÄÔ∏è Created ${flareObjects.length} spectacular solar flare visualizations`);
            
            // Trigger story event for solar flares
            if (flareObjects.length > 0) {
                setTimeout(() => triggerStoryEvent('solar_flare'), 1000);
            }
        }

        function updateConnectionStatus(status) {
            const statusElement = document.getElementById('data-status');
            const indicator = statusElement.querySelector('.status-indicator');
            
            indicator.className = `status-indicator status-${status}`;
            
            switch (status) {
                case 'online':
                    statusElement.innerHTML = '<span class="status-indicator status-online"></span>LIVE';
                    break;
                case 'loading':
                    statusElement.innerHTML = '<span class="status-indicator status-loading"></span>LOADING';
                    break;
                case 'offline':
                    statusElement.innerHTML = '<span class="status-indicator status-offline"></span>OFFLINE';
                    break;
            }
        }

        function showEmergencyAlert(cme) {
            // In story mode, show friendly notification instead of alert
            if (storyMode) {
                const speed = cme.speed || 1000;
                showNotification(`üåû Sunny is sending a fast solar wind at ${speed.toLocaleString()} km/s! Terra's magnetic shield will protect us! üõ°Ô∏è`, 'info');
                return;
            }

            // Professional mode - show full alert with variety
            const alertPanel = document.getElementById('alert-panel');
            const alertContent = document.getElementById('alert-content');

            const speed = cme.speed || 1000;
            const eta = Math.round((150000000 / (speed * 1000)) / 3600); // Rough ETA in hours

            // Determine risk level and alert type based on speed
            let riskLevel, riskColor, alertTitle, alertIcon;
            if (speed > 1500) {
                riskLevel = 'EXTREME';
                riskColor = '#ff0000';
                alertTitle = 'üö® EXTREME CME WARNING';
                alertIcon = 'üö®';
            } else if (speed > 1000) {
                riskLevel = 'SEVERE';
                riskColor = '#ff6600';
                alertTitle = '‚ö†Ô∏è HIGH-SPEED CME DETECTED';
                alertIcon = '‚ö†Ô∏è';
            } else if (speed > 700) {
                riskLevel = 'MODERATE';
                riskColor = '#ffaa00';
                alertTitle = '‚ö° MODERATE CME ALERT';
                alertIcon = '‚ö°';
            } else {
                riskLevel = 'LOW';
                riskColor = '#ffff00';
                alertTitle = 'üì¢ CME DETECTION NOTICE';
                alertIcon = 'üì¢';
            }

            // Get source location
            const source = cme.sourceLocation || cme.source_location || cme.activityID || `S${Math.floor(Math.random() * 20) + 10}W${Math.floor(Math.random() * 40) + 10}`;

            alertContent.innerHTML = `
                <div style="font-size: 1.4rem; margin-bottom: 15px; color: #ffffff;">
                    ${alertTitle}
                </div>
                <div style="font-size: 1.1rem; line-height: 1.5;">
                    <strong>Speed:</strong> ${speed.toLocaleString()} km/s<br>
                    <strong>ETA:</strong> ${eta === 0 ? '< 1 hour' : `~${eta} hours`}<br>
                    <strong>Risk Level:</strong> <span style="color: ${riskColor}; font-weight: 700;">${riskLevel}</span><br>
                    <strong>Source:</strong> ${source}
                </div>
            `;

            alertPanel.style.display = 'block';

            // Auto-hide after 10 seconds
            setTimeout(() => {
                if (alertPanel.style.display === 'block') {
                    alertPanel.style.display = 'none';
                }
            }, 10000);
        }

        function dismissAlert() {
            const alertPanel = document.getElementById('alert-panel');
            if (alertPanel) {
                alertPanel.style.display = 'none';
                console.log('Alert dismissed successfully');
            }
        }

        function hideAllAlerts() {
            const alertPanel = document.getElementById('alert-panel');
            if (alertPanel) {
                alertPanel.style.display = 'none';
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;
            
            // Performance monitoring
            frameCount++;
            if (time - lastTime >= 1.0) {
                fps = frameCount / (time - lastTime);
                frameCount = 0;
                lastTime = time;
                
                // Auto-adjust quality based on FPS
                if (autoQuality) {
                    if (fps < 30 && particleIntensity > 0.3) {
                        particleIntensity = Math.max(0.3, particleIntensity - 0.1);
                        console.log(`üîß Auto-reduced quality: FPS ${fps.toFixed(1)}, Intensity ${particleIntensity}`);
                    } else if (fps > 50 && particleIntensity < 1.0) {
                        particleIntensity = Math.min(1.0, particleIntensity + 0.05);
                    }
                }
            }

            if (animationRunning) {
                // Optimized shader uniform updates (only update specific objects)
                if (sun && sun.material.uniforms) {
                    sun.material.uniforms.time.value = time * timeSpeed;
                    sun.material.uniforms.intensity.value = particleIntensity;
                }
                
                // Update star material time uniform
                const stars = scene.children.find(child => child.type === 'Points');
                if (stars && stars.material.uniforms) {
                    stars.material.uniforms.time.value = time * timeSpeed;
                }

                // Animate solar system
                if (sun) {
                    sun.rotation.y += 0.01 * timeSpeed;
                }

                if (earth) {
                    const earthOrbit = time * 0.1 * timeSpeed;
                    earth.parent.position.x = Math.cos(earthOrbit) * 150;
                    earth.parent.position.z = Math.sin(earthOrbit) * 150;
                    earth.rotation.y += 0.02 * timeSpeed;
                }

                if (moon) {
                    const moonOrbit = time * 0.5 * timeSpeed;
                    moon.position.x = earth.parent.position.x + Math.cos(moonOrbit) * 15;
                    moon.position.z = earth.parent.position.z + Math.sin(moonOrbit) * 15;
                }

                // Animate CME particles
                cmeObjects.forEach((cmeGroup) => {
                    const cme = cmeGroup.children[0];
                    if (cme && cme.userData.velocities) {
                        const elapsed = (Date.now() - cme.userData.startTime) / 1000;
                        const positions = cme.geometry.attributes.position.array;
                        const velocities = cme.userData.velocities;
                        const originalPositions = cme.userData.originalPositions;

                        for (let i = 0; i < positions.length; i += 3) {
                            // Update positions based on velocities
                            positions[i] = originalPositions[i] + velocities[i] * elapsed * 50;
                            positions[i + 1] = originalPositions[i + 1] + velocities[i + 1] * elapsed * 50;
                            positions[i + 2] = originalPositions[i + 2] + velocities[i + 2] * elapsed * 50;
                        }

                        cme.geometry.attributes.position.needsUpdate = true;

                        // Fade out over time
                        if (elapsed > 60) {
                            cme.material.uniforms.intensity.value = Math.max(0, particleIntensity * (1 - (elapsed - 60) / 30));
                        }
                    }
                });

                // Animate continuous solar wind
                solarWindParticles.forEach(windSystem => {
                    const positions = windSystem.geometry.attributes.position.array;
                    const velocities = windSystem.geometry.attributes.velocity.array;
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i] += velocities[i] * timeSpeed;
                        positions[i + 1] += velocities[i + 1] * timeSpeed;
                        positions[i + 2] += velocities[i + 2] * timeSpeed;
                        
                        // Reset particles that go too far
                        const distance = Math.sqrt(positions[i]**2 + positions[i + 1]**2 + positions[i + 2]**2);
                        if (distance > 300) {
                            const angle = Math.random() * Math.PI * 2;
                            const radius = 25 + Math.random() * 15;
                            positions[i] = Math.cos(angle) * radius;
                            positions[i + 1] = (Math.random() - 0.5) * 20;
                            positions[i + 2] = Math.sin(angle) * radius;
                        }
                    }
                    windSystem.geometry.attributes.position.needsUpdate = true;
                });

                // Update physics calculations (only every 10 frames for performance)
                if (Math.floor(time * 60) % 10 === 0) {
                    updatePhysicsDisplay();
                }

                // Update camera for cinematic mode with spectacular movements
                if (cameraMode === 'cinematic') {
                    const radius = 250 + Math.sin(time * 0.03) * 50;
                    camera.position.x = Math.cos(time * 0.08) * radius;
                    camera.position.y = 80 + Math.sin(time * 0.04) * 60;
                    camera.position.z = Math.sin(time * 0.08) * radius;
                    
                    // Dynamic look target for more dramatic effect
                    const lookX = Math.sin(time * 0.02) * 30;
                    const lookY = Math.cos(time * 0.015) * 20;
                    camera.lookAt(lookX, lookY, 0);
                }
            }

            renderer.render(scene, camera);
        }

        function updatePhysicsDisplay() {
            // Update orbital velocity
            const orbitalVel = (29.78 + Math.sin(Date.now() * 0.001) * 0.5).toFixed(2);
            document.getElementById('orbital-velocity').textContent = orbitalVel;

            // Update magnetic field
            const magneticField = (3.12e-5 + Math.sin(Date.now() * 0.002) * 0.5e-5).toExponential(2);
            document.getElementById('magnetic-field').textContent = magneticField;

            // Update Dst index
            const dst = Math.round(-15 + Math.sin(Date.now() * 0.0015) * 20);
            document.getElementById('dst-index').textContent = Math.abs(dst);
        }

        // Control functions
        function toggleAnimation() {
            animationRunning = !animationRunning;
            console.log('Animation:', animationRunning ? 'Playing' : 'Paused');
        }

        function resetView() {
            camera.position.set(0, 200, 400);
            camera.lookAt(0, 0, 0);
            setCameraMode('overview');
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        function captureScreenshot() {
            try {
                // Force a render to ensure the canvas is up to date
                renderer.render(scene, camera);
                
                // Get the canvas data with error handling
                const canvas = renderer.domElement;
                const dataURL = canvas.toDataURL('image/png', 1.0);
                
                if (dataURL === 'data:,') {
                    throw new Error('Canvas is blank');
                }
                
                // Create download link
                const link = document.createElement('a');
                const timestamp = new Date().toISOString().replace(/[:.]/g, '_').slice(0, 19);
                link.download = `helioearth_3d_space_weather_${timestamp}.png`;
                link.href = dataURL;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                console.log('üì∏ Screenshot captured successfully');
                
                // Show user feedback
                showCaptureNotification();
                
            } catch (error) {
                console.error('Screenshot capture failed:', error);
                console.warn('üì∏ Screenshot capture failed. Using system screenshot tool is recommended (Windows+Shift+S or Cmd+Shift+4)');
                // Show non-intrusive notification instead of alert
                showNotification('üì∏ Screenshot feature not available. Use system tools: Windows+Shift+S or Cmd+Shift+4', 'warning');
            }
        }

        // General notification system
        function showNotification(message, type = 'info') {
            const colors = {
                info: 'linear-gradient(135deg, #4a90e2, #5ba3f5)',
                success: 'linear-gradient(135deg, #4CAF50, #66BB6A)',
                warning: 'linear-gradient(135deg, #FF9800, #FFB74D)',
                error: 'linear-gradient(135deg, #F44336, #EF5350)'
            };
            
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${colors[type]};
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                font-family: 'Orbitron', monospace;
                font-size: 0.9rem;
                z-index: 10000;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
                opacity: 0;
                transition: opacity 0.3s ease;
                max-width: 300px;
                word-wrap: break-word;
            `;
            notification.innerHTML = message;
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => notification.style.opacity = '1', 100);
            
            // Remove after 4 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 4000);
        }

        function showCaptureNotification() {
            showNotification('üì∏ Screenshot captured successfully!', 'success');
        }

        function showCaptureNotificationOld() {
            // Create temporary notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #4a90e2, #5ba3f5);
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                font-family: 'Orbitron', monospace;
                font-size: 0.9rem;
                z-index: 10000;
                box-shadow: 0 4px 15px rgba(74, 144, 226, 0.3);
                opacity: 0;
                transition: opacity 0.3s ease;
            `;
            notification.innerHTML = 'üì∏ Screenshot captured successfully!';
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => notification.style.opacity = '1', 100);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => document.body.removeChild(notification), 300);
            }, 3000);
        }

        function setCameraMode(mode) {
            cameraMode = mode;
            
            // Update button states
            document.querySelectorAll('.control-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`btn-${mode}`).classList.add('active');

            switch (mode) {
                case 'overview':
                    camera.position.set(0, 200, 400);
                    camera.lookAt(0, 0, 0);
                    if (storyMode) switchCharacter('aurora');
                    break;
                case 'earth':
                    camera.position.set(150, 50, 100);
                    camera.lookAt(150, 0, 0);
                    if (storyMode) {
                        switchCharacter('terra');
                        setTimeout(() => triggerStoryEvent('aurora_display'), 1500);
                    }
                    break;
                case 'sun':
                    camera.position.set(0, 50, 80);
                    camera.lookAt(0, 0, 0);
                    if (storyMode) switchCharacter('sunny');
                    break;
                case 'cinematic':
                    // Cinematic mode is handled in animate function
                    if (storyMode) switchCharacter('aurora');
                    break;
            }
        }

        function updateTimeSpeed(value) {
            timeSpeed = parseFloat(value);
            document.getElementById('speed-display').textContent = value + 'x';
        }

        function updateParticleIntensity(value) {
            particleIntensity = parseFloat(value);
        }

        function togglePhysicsModel(model) {
            physicsModels[model] = !physicsModels[model];
            const btn = document.getElementById(`btn-${model}-model`);
            if (btn) {
                btn.classList.toggle('active');
            }
            console.log(`Physics model ${model}:`, physicsModels[model] ? 'ON' : 'OFF');
        }

        function focusOnCME(index) {
            console.log('Focusing on CME:', index);
            setCameraMode('sun');
        }

        function focusOnFlare(index) {
            console.log('Focusing on flare:', index);
            setCameraMode('sun');
        }

        function onWindowResize() {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }


        // Initialize when page loads
        // Voice system initialization
        let voicesLoaded = false;
        function initializeVoiceSystem() {
            console.log('üé§ Initializing voice system...');

            // Load voices immediately
            const initialVoices = speechSynthesis.getVoices();
            if (initialVoices.length > 0) {
                voicesLoaded = true;
                console.log(`‚úÖ Voice system ready! ${initialVoices.length} voices available:`);
                initialVoices.slice(0, 5).forEach(v => {
                    console.log(`  - ${v.name} (${v.lang})`);
                });
            }

            // Listen for voices to be loaded (for browsers that load async)
            speechSynthesis.addEventListener('voiceschanged', () => {
                const voices = speechSynthesis.getVoices();
                if (voices.length > 0 && !voicesLoaded) {
                    voicesLoaded = true;
                    console.log(`‚úÖ Voice system ready! ${voices.length} voices loaded:`);
                    voices.slice(0, 5).forEach(v => {
                        console.log(`  - ${v.name} (${v.lang})`);
                    });
                }
            }, { once: true });

            // Force trigger voice loading
            setTimeout(() => {
                speechSynthesis.getVoices();
            }, 100);
        }

        document.addEventListener('DOMContentLoaded', () => {
            console.log('üöÄ Starting Spectacular Space Weather Observatory...');

            // Check if opened from dashboard with story mode parameter
            const urlParams = new URLSearchParams(window.location.search);
            const storyModeParam = urlParams.get('mode');

            // Load dashboard data if available
            const dashboardData = localStorage.getItem('helioearth_live_data');
            if (dashboardData) {
                try {
                    const liveData = JSON.parse(dashboardData);
                    console.log('üìä Received live data from dashboard:', liveData);

                    // Store for use in story mode
                    window.dashboardLiveData = liveData;
                } catch (e) {
                    console.warn('Failed to parse dashboard data:', e);
                }
            }

            // Auto-enable story mode if parameter is set
            if (storyModeParam === 'story') {
                console.log('üìö Auto-enabling Story Mode from dashboard...');
                // Enable story mode after initialization
                setTimeout(() => {
                    if (!storyMode) {
                        toggleStoryMode();
                    }
                }, 1500);
            }

            // Initialize voice system first
            initializeVoiceSystem();

            // Initialize spectacular observatory immediately
            setTimeout(() => {
                init();
            }, 100);
        });

        // WebSocket handler
        window.updateSpectacularObservatoryWithLiveData = function(data) {
            console.log('üåå Observatory receiving real-time data:', data);
            
            if (data.events) {
                nasaData = data;
                updateDataDisplay();
                createSpectacularCMEVisualization();
                createSpectacularFlareVisualization();
            }
        };

        // Help Center Functions
        function openHelpCenter() {
            const helpCenter = document.getElementById('help-center');
            if (helpCenter) {
                helpCenter.style.display = 'flex';
                document.body.style.overflow = 'hidden';
                console.log('Help Center opened');
            }
        }

        function closeHelpCenter() {
            const helpCenter = document.getElementById('help-center');
            if (helpCenter) {
                helpCenter.style.display = 'none';
                document.body.style.overflow = 'auto';
                console.log('Help Center closed');
            }
        }

        // Initialize help center event listeners after DOM loads
        window.addEventListener('DOMContentLoaded', () => {
            // Close help center with Escape key
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    closeHelpCenter();
                }
            });

            // Close help center when clicking outside content
            const helpCenter = document.getElementById('help-center');
            if (helpCenter) {
                helpCenter.addEventListener('click', (event) => {
                    if (event.target.id === 'help-center') {
                        closeHelpCenter();
                    }
                });

                // Prevent clicks inside help content from closing it
                const helpContent = helpCenter.querySelector('.help-content');
                if (helpContent) {
                    helpContent.addEventListener('click', (event) => {
                        event.stopPropagation();
                    });
                }
            }

            console.log('Help Center event listeners initialized');
        });
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</body>
</html>