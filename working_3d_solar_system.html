<!DOCTYPE html>
<html>
<head>
    <title>üõ∞Ô∏è NASA Professional Space Weather Observatory</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Inter:wght@300;400;500;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            background: radial-gradient(ellipse at center, #001122 0%, #000814 70%, #000000 100%);
            color: #ffffff;
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            position: relative;
        }
        
        .stars {
            position: absolute;
            width: 100%;
            height: 100%;
            background: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIj4KICA8ZGVmcz4KICAgIDxyYWRpYWxHcmFkaWVudCBpZD0ic3RhciI+CiAgICAgIDxzdG9wIG9mZnNldD0iMCUiIHN0b3AtY29sb3I9IndoaXRlIiBzdG9wLW9wYWNpdHk9IjEiLz4KICAgICAgPHN0b3Agb2Zmc2V0PSIxMDAlIiBzdG9wLWNvbG9yPSJ3aGl0ZSIgc3RvcC1vcGFjaXR5PSIwIi8+CiAgICA8L3JhZGlhbEdyYWRpZW50PgogIDwvZGVmcz4KICA8Y2lyY2xlIGN4PSIyIiBjeT0iMiIgcj0iMSIgZmlsbD0idXJsKCNzdGFyKSIgb3BhY2l0eT0iMC44Ii8+CiAgPGNpcmNsZSBjeD0iNDAiIGN5PSIzMCIgcj0iMC41IiBmaWxsPSJ1cmwoI3N0YXIpIiBvcGFjaXR5PSIwLjYiLz4KICA8Y2lyY2xlIGN4PSIxMDAiIGN5PSI1MCIgcj0iMC44IiBmaWxsPSJ1cmwoI3N0YXIpIiBvcGFjaXR5PSIwLjciLz4KICA8Y2lyY2xlIGN4PSIxNjAiIGN5PSIyMCIgcj0iMC42IiBmaWxsPSJ1cmwoI3N0YXIpIiBvcGFjaXR5PSIwLjUiLz4KICA8Y2lyY2xlIGN4PSIxODAiIGN5PSIxMjAiIHI9IjEiIGZpbGw9InVybCgjc3RhcikiIG9wYWNpdHk9IjAuOCIvPgo8L3N2Zz4=') repeat;
            animation: twinkle 3s ease-in-out infinite alternate;
        }
        
        @keyframes twinkle {
            0% { opacity: 0.3; }
            100% { opacity: 1; }
        }
        
        .hud-panel {
            position: absolute;
            background: linear-gradient(135deg, rgba(0, 25, 50, 0.95) 0%, rgba(0, 15, 30, 0.95) 100%);
            border: 1px solid rgba(0, 150, 255, 0.3);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 150, 255, 0.1);
            padding: 20px;
            font-family: 'Inter', sans-serif;
        }
        
        .hud-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent 0%, #00aaff 50%, transparent 100%);
            border-radius: 12px 12px 0 0;
        }
        
        #main-hud {
            top: 15px;
            left: 15px;
            width: 240px;
            min-height: 280px;
        }
        
        #controls-panel {
            top: 15px;
            right: 15px;
            width: 200px;
        }
        
        #analysis-panel {
            bottom: 15px;
            left: 15px;
            width: 280px;
            height: 140px;
        }
        
        #forecast-panel {
            bottom: 15px;
            right: 15px;
            width: 250px;
            height: 140px;
        }
        
        .panel-title {
            font-family: 'Orbitron', monospace;
            font-size: 12px;
            font-weight: 700;
            color: #00ddff;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .panel-title::before {
            content: '';
            width: 8px;
            height: 8px;
            background: #00ddff;
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-bottom: 10px;
        }
        
        .status-item {
            background: rgba(0, 50, 100, 0.2);
            border: 1px solid rgba(0, 150, 255, 0.2);
            border-radius: 6px;
            padding: 6px;
            text-align: center;
        }
        
        .status-label {
            font-size: 9px;
            color: #88ccff;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            margin-bottom: 2px;
        }
        
        .status-value {
            font-family: 'Orbitron', monospace;
            font-size: 10px;
            font-weight: 600;
            color: #ffffff;
        }
        
        .status-value.critical { color: #ff4444; }
        .status-value.warning { color: #ffaa00; }
        .status-value.normal { color: #44ff88; }
        
        .control-button {
            background: linear-gradient(135deg, #0066cc 0%, #004499 100%);
            color: white;
            border: 1px solid rgba(0, 150, 255, 0.3);
            padding: 8px 10px;
            margin: 3px 0;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            font-size: 10px;
            font-weight: 500;
            width: 100%;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .control-button:hover {
            background: linear-gradient(135deg, #0088ff 0%, #0066cc 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 16px rgba(0, 150, 255, 0.3);
        }
        
        .control-button:active {
            transform: translateY(0);
        }
        
        .activity-log {
            background: rgba(0, 20, 40, 0.5);
            border-radius: 4px;
            padding: 6px;
            height: 100px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 9px;
            line-height: 1.2;
        }
        
        .log-entry {
            color: #aaccff;
            margin-bottom: 3px;
        }
        
        .log-entry.warning { color: #ffcc88; }
        .log-entry.error { color: #ff8888; }
        .log-entry.success { color: #88ff88; }
        
        .data-viz {
            height: 80px;
            background: rgba(0, 20, 40, 0.3);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }
        
        .kp-indicator {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
        }
        
        .kp-bar {
            width: 8%;
            height: 30px;
            border-radius: 2px;
            display: flex;
            align-items: end;
            justify-content: center;
            font-size: 10px;
            color: white;
            font-weight: bold;
        }
        
        .loading-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid rgba(0, 150, 255, 0.3);
            border-top: 2px solid #00ddff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 8px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        canvas { display: block; }
        
        .aurora-visualization {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 2s ease;
        }
        
        .aurora-active {
            opacity: 0.6;
            background: radial-gradient(ellipse at center, rgba(0, 255, 100, 0.1) 0%, transparent 70%);
        }
        
        .help-center {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }
        
        .help-center.active {
            display: flex;
        }
        
        .help-modal {
            background: linear-gradient(135deg, rgba(0, 25, 50, 0.98) 0%, rgba(0, 15, 30, 0.98) 100%);
            border: 2px solid rgba(0, 150, 255, 0.4);
            border-radius: 16px;
            backdrop-filter: blur(20px);
            box-shadow: 0 20px 60px rgba(0, 150, 255, 0.2);
            padding: 30px;
            max-width: 900px;
            width: 90%;
            max-height: 80%;
            overflow-y: auto;
            font-family: 'Inter', sans-serif;
        }
        
        .help-modal::-webkit-scrollbar {
            width: 8px;
        }
        
        .help-modal::-webkit-scrollbar-track {
            background: rgba(0, 50, 100, 0.2);
            border-radius: 4px;
        }
        
        .help-modal::-webkit-scrollbar-thumb {
            background: rgba(0, 150, 255, 0.5);
            border-radius: 4px;
        }
        
        .help-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid rgba(0, 150, 255, 0.3);
        }
        
        .help-title {
            font-family: 'Orbitron', monospace;
            font-size: 24px;
            font-weight: 900;
            color: #00ddff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .help-close {
            background: none;
            border: 2px solid rgba(255, 100, 100, 0.5);
            color: #ff6666;
            font-size: 24px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .help-close:hover {
            background: rgba(255, 100, 100, 0.2);
            transform: scale(1.1);
        }
        
        .help-nav {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .help-nav-btn {
            background: linear-gradient(135deg, rgba(0, 100, 200, 0.3) 0%, rgba(0, 50, 100, 0.3) 100%);
            border: 1px solid rgba(0, 150, 255, 0.3);
            color: #aaccff;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        
        .help-nav-btn:hover,
        .help-nav-btn.active {
            background: linear-gradient(135deg, rgba(0, 150, 255, 0.3) 0%, rgba(0, 100, 200, 0.3) 100%);
            color: #ffffff;
            transform: translateY(-2px);
        }
        
        .help-content {
            display: none;
        }
        
        .help-content.active {
            display: block;
        }
        
        .help-section {
            margin-bottom: 30px;
        }
        
        .help-section h3 {
            font-family: 'Orbitron', monospace;
            font-size: 18px;
            color: #00ddff;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .help-section p {
            color: #ccddff;
            line-height: 1.6;
            margin-bottom: 15px;
        }
        
        .help-section ul {
            color: #aaccff;
            margin-left: 20px;
            margin-bottom: 15px;
        }
        
        .help-section li {
            margin-bottom: 8px;
            line-height: 1.5;
        }
        
        .help-code {
            background: rgba(0, 50, 100, 0.3);
            border: 1px solid rgba(0, 150, 255, 0.2);
            border-radius: 6px;
            padding: 12px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            color: #88ff88;
            font-size: 13px;
            overflow-x: auto;
        }
        
        .help-warning {
            background: rgba(255, 150, 0, 0.1);
            border-left: 4px solid #ffaa00;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
            color: #ffcc88;
        }
        
        .help-tip {
            background: rgba(0, 255, 100, 0.1);
            border-left: 4px solid #44ff88;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
            color: #aaffcc;
        }
    </style>
</head>
<body>
    <div class="stars"></div>
    <div class="aurora-visualization" id="aurora"></div>
    
    <!-- Main HUD Panel -->
    <div class="hud-panel" id="main-hud">
        <div class="panel-title">üõ∞Ô∏è Space Weather Observatory</div>
        
        <div class="status-grid">
            <div class="status-item">
                <div class="status-label">Solar Activity</div>
                <div class="status-value normal" id="solar">Moderate</div>
            </div>
            <div class="status-item">
                <div class="status-label">Kp Index</div>
                <div class="status-value normal" id="kp">2.3</div>
            </div>
            <div class="status-item">
                <div class="status-label">Solar Wind</div>
                <div class="status-value normal" id="wind">450 km/s</div>
            </div>
            <div class="status-item">
                <div class="status-label">CME Events</div>
                <div class="status-value normal" id="cme">0 Active</div>
            </div>
            <div class="status-item">
                <div class="status-label">Aurora Latitude</div>
                <div class="status-value normal" id="aurora-lat">67.0¬∞</div>
            </div>
            <div class="status-item">
                <div class="status-label">Dst Index</div>
                <div class="status-value normal" id="dst-index">-15 nT</div>
            </div>
            <div class="status-item">
                <div class="status-label">Bz Component</div>
                <div class="status-value normal" id="bz-field">-2.0 nT</div>
            </div>
            <div class="status-item">
                <div class="status-label">SW Pressure</div>
                <div class="status-value normal" id="sw-pressure">2.5 nPa</div>
            </div>
            <div class="status-item">
                <div class="status-label">Data Source</div>
                <div class="status-value normal" id="data-status">NASA/NOAA</div>
            </div>
            <div class="status-item">
                <div class="status-label">CME Arrivals</div>
                <div class="status-value normal" id="cme-arrivals">0 Predicted</div>
            </div>
        </div>
        
        <div class="kp-indicator">
            <div class="kp-bar" style="background: #44ff88; height: 20px;">0</div>
            <div class="kp-bar" style="background: #44ff88; height: 25px;">1</div>
            <div class="kp-bar" style="background: #88ff44; height: 30px;">2</div>
            <div class="kp-bar" style="background: #ffff44; height: 15px;">3</div>
            <div class="kp-bar" style="background: #ffaa44; height: 10px;">4</div>
            <div class="kp-bar" style="background: #ff8844; height: 8px;">5</div>
            <div class="kp-bar" style="background: #ff4444; height: 5px;">6</div>
            <div class="kp-bar" style="background: #ff2222; height: 3px;">7</div>
            <div class="kp-bar" style="background: #cc0000; height: 2px;">8</div>
        </div>
        
        <div class="activity-log" id="activity-log">
            <div class="log-entry success">[INIT] Observatory systems online</div>
            <div class="log-entry">[DATA] Connecting to NASA DONKI API...</div>
            <div class="log-entry">[SYS] 3D visualization engine started</div>
        </div>
    </div>
    
    <!-- Controls Panel -->
    <div class="hud-panel" id="controls-panel">
        <div class="panel-title">üéõÔ∏è Mission Control</div>
        
        <button class="control-button" onclick="simulateCME()">
            <span>üåû</span> Simulate CME Event
        </button>
        <button class="control-button" onclick="analyzeWeather()">
            <span>üìä</span> Analyze Conditions
        </button>
        <button class="control-button" onclick="generateForecast()">
            <span>üîÆ</span> Generate Forecast
        </button>
        <button class="control-button" onclick="loadNASAData()">
            <span>üì°</span> Sync NASA Data
        </button>
        <button class="control-button" id="aurora-monitor-btn" onclick="toggleAurora()">
            <span>üåå</span> <span id="aurora-status">Aurora: QUIET</span>
        </button>
        <button class="control-button" onclick="exportData()">
            <span>üíæ</span> Export Analysis
        </button>
        <button class="control-button" onclick="openHelpCenter()">
            <span>‚ùì</span> Help & Support
        </button>
    </div>
    
    <!-- Analysis Panel -->
    <div class="hud-panel" id="analysis-panel">
        <div class="panel-title">üìà Real-Time Analysis</div>
        <div class="data-viz" id="solar-wind-chart">
            <canvas id="chart-canvas" width="260" height="70"></canvas>
        </div>
    </div>
    
    <!-- Forecast Panel -->
    <div class="hud-panel" id="forecast-panel">
        <div class="panel-title">üîÆ 24h Forecast</div>
        <div id="forecast-content">
            <div style="margin: 10px 0; font-size: 13px; color: #aaccff;">
                Geomagnetic Conditions: <strong style="color: #44ff88;">Quiet</strong>
            </div>
            <div style="margin: 10px 0; font-size: 13px; color: #aaccff;">
                Aurora Visibility: <strong style="color: #ffaa44;">Northern Canada</strong>
            </div>
            <div style="margin: 10px 0; font-size: 13px; color: #aaccff;">
                Radio Impact: <strong style="color: #44ff88;">None Expected</strong>
            </div>
            <div style="margin: 10px 0; font-size: 12px; color: #888;">
                Last Updated: <span id="forecast-time">--:--</span>
            </div>
        </div>
    </div>

    <!-- Help Center Modal -->
    <div class="help-center" id="helpCenter">
        <div class="help-modal">
            <div class="help-header">
                <h2 class="help-title">üõ∞Ô∏è Space Weather Observatory Guide</h2>
                <button class="help-close" onclick="closeHelpCenter()">√ó</button>
            </div>
            
            <div class="help-nav">
                <button class="help-nav-btn active" onclick="showHelpSection('overview')">Overview</button>
                <button class="help-nav-btn" onclick="showHelpSection('controls')">Controls</button>
                <button class="help-nav-btn" onclick="showHelpSection('data')">Data Sources</button>
                <button class="help-nav-btn" onclick="showHelpSection('analysis')">Analysis</button>
                <button class="help-nav-btn" onclick="showHelpSection('troubleshooting')">Troubleshooting</button>
                <button class="help-nav-btn" onclick="showHelpSection('api')">API Reference</button>
            </div>
            
            <div class="help-content active" id="help-overview">
                <div class="help-section">
                    <h3>üåå Professional Space Weather Observatory</h3>
                    <p>This is a cutting-edge, NASA-grade space weather monitoring and analysis platform featuring real-time 3D visualization, scientific data integration, and professional forecasting capabilities.</p>
                    
                    <h3>üéØ Key Features</h3>
                    <ul>
                        <li><strong>Real-time 3D Solar System:</strong> Accurate orbital mechanics with Sun, Earth, and Moon</li>
                        <li><strong>NASA API Integration:</strong> Live data from DONKI, NOAA SWPC, and ACE spacecraft</li>
                        <li><strong>Scientific Physics Models:</strong> CME propagation, Kp index calculation, Dst prediction</li>
                        <li><strong>Professional Aurora Monitoring:</strong> 5-level intensity classification system</li>
                        <li><strong>Interactive Particle Physics:</strong> Solar wind and CME simulation with magnetosphere interaction</li>
                        <li><strong>Scientific Data Export:</strong> NASA-compatible JSON format with full metadata</li>
                        <li><strong>24-hour Forecasting:</strong> Geomagnetic storm and aurora visibility predictions</li>
                    </ul>
                    
                    <div class="help-tip">
                        <strong>üí° Pro Tip:</strong> Use keyboard shortcuts for rapid operation: C (CME), A (Analyze), F (Forecast), N (NASA Sync), R (Aurora), E (Export), Space (Reset View)
                    </div>
                </div>
            </div>
            
            <div class="help-content" id="help-controls">
                <div class="help-section">
                    <h3>üéõÔ∏è Mission Control Interface</h3>
                    
                    <h3>üåû Simulate CME Event</h3>
                    <p>Creates a realistic Coronal Mass Ejection with physics-based particle simulation. CME particles are directed toward Earth and interact with the magnetosphere to create aurora effects.</p>
                    <div class="help-code">Keyboard Shortcut: C</div>
                    
                    <h3>üìä Analyze Conditions</h3>
                    <p>Performs comprehensive space weather analysis using current solar wind parameters, magnetic field data, and scientific models to calculate Kp index, activity levels, and risks.</p>
                    <div class="help-code">Keyboard Shortcut: A</div>
                    
                    <h3>üîÆ Generate Forecast</h3>
                    <p>Creates a 24-hour geomagnetic forecast based on current conditions, CME arrivals, and statistical models. Includes aurora visibility predictions and radio impact assessments.</p>
                    <div class="help-code">Keyboard Shortcut: F</div>
                    
                    <h3>üì° Sync NASA Data</h3>
                    <p>Downloads real-time data from NASA DONKI (space weather events), NOAA SWPC (solar wind), and ACE spacecraft (magnetic field). Updates every 5 minutes automatically.</p>
                    <div class="help-code">Keyboard Shortcut: N</div>
                    
                    <h3>üåå Aurora Monitor</h3>
                    <p>Professional 5-level aurora intensity monitoring system: QUIET ‚Üí MINOR ‚Üí MODERATE ‚Üí ACTIVE ‚Üí SEVERE. Color-coded button indicates current auroral activity level.</p>
                    <div class="help-code">Keyboard Shortcut: R</div>
                    
                    <h3>üíæ Export Analysis</h3>
                    <p>Exports comprehensive scientific data in NASA-compatible JSON format including metadata, current conditions, predictions, and scientific references.</p>
                    <div class="help-code">Keyboard Shortcut: E</div>
                </div>
            </div>
            
            <div class="help-content" id="help-data">
                <div class="help-section">
                    <h3>üì° Data Sources & Integration</h3>
                    
                    <h3>üõ∞Ô∏è NASA DONKI API</h3>
                    <p>Database Of Notifications, Knowledge, Information for space weather events:</p>
                    <ul>
                        <li><strong>CME Events:</strong> Coronal Mass Ejections with speed, direction, and arrival predictions</li>
                        <li><strong>Solar Flares:</strong> X-ray flare classification and intensity measurements</li>
                        <li><strong>Geomagnetic Storms:</strong> Kp index values and storm classifications</li>
                        <li><strong>Solar Energetic Particles:</strong> High-energy particle events</li>
                    </ul>
                    
                    <h3>üå¨Ô∏è NOAA SWPC Real-time Data</h3>
                    <p>Space Weather Prediction Center live measurements:</p>
                    <ul>
                        <li><strong>Solar Wind Speed:</strong> Velocity measurements from ACE spacecraft (km/s)</li>
                        <li><strong>Particle Density:</strong> Proton density in solar wind (particles/cm¬≥)</li>
                        <li><strong>Magnetic Field:</strong> Interplanetary magnetic field components (nT)</li>
                        <li><strong>Dynamic Pressure:</strong> Solar wind ram pressure (nPa)</li>
                    </ul>
                    
                    <h3>üßÆ Scientific Models</h3>
                    <ul>
                        <li><strong>Drag-Based Model (DBM):</strong> CME propagation and arrival time calculation</li>
                        <li><strong>Burton et al. (1975):</strong> Dst index prediction from solar wind parameters</li>
                        <li><strong>Newell et al. (2007):</strong> Kp index coupling function</li>
                        <li><strong>Holzworth & Meng (1975):</strong> Auroral oval latitude calculation</li>
                    </ul>
                    
                    <div class="help-warning">
                        <strong>‚ö†Ô∏è Data Limitations:</strong> Real-time data may have delays of 1-5 minutes. During API outages, the system uses scientifically realistic simulated data.
                    </div>
                </div>
            </div>
            
            <div class="help-content" id="help-analysis">
                <div class="help-section">
                    <h3>üìà Scientific Analysis Methods</h3>
                    
                    <h3>üå™Ô∏è Kp Index Calculation</h3>
                    <p>The planetary geomagnetic index is calculated using the empirical coupling function:</p>
                    <div class="help-code">VBs = v √ó |Bz| √ó ‚àö(n)<br>Kp = f(VBs^(2/3))</div>
                    <p>Where v = solar wind speed, Bz = magnetic field z-component, n = particle density</p>
                    
                    <h3>üß≤ Dst Index Prediction</h3>
                    <p>Ring current disturbance storm time index using Burton model:</p>
                    <div class="help-code">Ey = v √ó |Bz| √ó 10‚Åª¬≥<br>Injection Rate = -4.4 √ó (Ey - 0.49)<br>Dst = -50 √ó log‚ÇÅ‚ÇÄ(P + 1) + Injection Rate</div>
                    
                    <h3>üåà Aurora Oval Calculation</h3>
                    <p>Auroral boundary latitude based on Kp index:</p>
                    <div class="help-code">Latitude = 67¬∞ - (2.5¬∞ √ó Kp)<br>Width = 3¬∞ + (0.5¬∞ √ó Kp)</div>
                    
                    <h3>‚è∞ CME Arrival Time</h3>
                    <p>Drag-Based Model for CME propagation:</p>
                    <div class="help-code">v(t) = vf + (v‚ÇÄ - vf) √ó exp(-Œ≥t)<br>Œ≥ = 0.2√ó10‚Åª‚Å∂ √ó vsw</div>
                    <p>Where v‚ÇÄ = initial CME speed, vf = final speed (solar wind), vsw = solar wind speed</p>
                    
                    <div class="help-tip">
                        <strong>üí° Analysis Frequency:</strong> Scientific analysis runs every 30 seconds to update all parameters and maintain real-time accuracy.
                    </div>
                </div>
            </div>
            
            <div class="help-content" id="help-troubleshooting">
                <div class="help-section">
                    <h3>üîß Troubleshooting Guide</h3>
                    
                    <h3>üåê Data Connection Issues</h3>
                    <p><strong>Problem:</strong> "API connection failed - using simulated data" message</p>
                    <ul>
                        <li>Check internet connection</li>
                        <li>NASA API may be temporarily unavailable</li>
                        <li>CORS restrictions in some browsers</li>
                        <li>System automatically switches to realistic simulated data</li>
                    </ul>
                    
                    <h3>üéÆ Performance Issues</h3>
                    <p><strong>Problem:</strong> Slow 3D rendering or particle effects</p>
                    <ul>
                        <li>Reduce browser zoom level</li>
                        <li>Close other browser tabs</li>
                        <li>Update graphics drivers</li>
                        <li>System automatically limits particle count for performance</li>
                    </ul>
                    
                    <h3>üì± Mobile/Tablet Display</h3>
                    <p><strong>Problem:</strong> HUD panels overlapping or too small</p>
                    <ul>
                        <li>Use landscape orientation</li>
                        <li>Panels automatically resize for smaller screens</li>
                        <li>Touch controls may be limited compared to mouse/keyboard</li>
                    </ul>
                    
                    <h3>üîÑ Reset Options</h3>
                    <ul>
                        <li><strong>Camera Reset:</strong> Press Space key to return to default view</li>
                        <li><strong>Data Refresh:</strong> Click "Sync NASA Data" to reload all data</li>
                        <li><strong>Browser Refresh:</strong> F5 to restart entire application</li>
                    </ul>
                    
                    <div class="help-warning">
                        <strong>‚ö†Ô∏è Browser Compatibility:</strong> Requires WebGL support. Best performance in Chrome, Firefox, or Edge. Safari may have limited features.
                    </div>
                </div>
            </div>
            
            <div class="help-content" id="help-api">
                <div class="help-section">
                    <h3>üîå API Reference & Integration</h3>
                    
                    <h3>üìä Data Export Format</h3>
                    <p>Scientific data is exported in NASA-compatible JSON structure:</p>
                    <div class="help-code">
{
  "metadata": {
    "title": "Space Weather Observatory Analysis",
    "version": "2.0.0",
    "timestamp": "ISO-8601",
    "source": "NASA DONKI, NOAA SWPC",
    "coordinate_system": "GSE",
    "units": { "speed": "km/s", "magnetic_field": "nT" }
  },
  "current_conditions": {
    "kp_index": 2.3,
    "solar_wind": { "speed": 450, "density": 5 },
    "dst_index": -15,
    "auroral_oval": { "latitude": 67.0, "intensity": 0.26 }
  },
  "predictions": {
    "next_24h_kp": [...],
    "cme_arrivals": [...],
    "aurora_forecast": [...]
  }
}
                    </div>
                    
                    <h3>üîó API Endpoints Used</h3>
                    <ul>
                        <li><strong>NASA DONKI CME:</strong> https://api.nasa.gov/DONKI/CME</li>
                        <li><strong>NASA DONKI Flares:</strong> https://api.nasa.gov/DONKI/FLR</li>
                        <li><strong>NASA DONKI Storms:</strong> https://api.nasa.gov/DONKI/GST</li>
                        <li><strong>NOAA Solar Wind:</strong> https://services.swpc.noaa.gov/products/solar-wind/ace-swepam.json</li>
                    </ul>
                    
                    <h3>üîë NASA API Key Setup</h3>
                    <p>To use your own NASA API key (recommended for production):</p>
                    <div class="help-code">
const NASA_API_KEY = 'your_api_key_here';
// Replace 'DEMO_KEY' in the source code
// Get free key at: https://api.nasa.gov/
                    </div>
                    
                    <h3>üìà Integration Examples</h3>
                    <p>Use exported data for:</p>
                    <ul>
                        <li>Automated space weather alerts</li>
                        <li>Research data analysis</li>
                        <li>Integration with other monitoring systems</li>
                        <li>Historical trend analysis</li>
                        <li>Custom visualization development</li>
                    </ul>
                    
                    <div class="help-tip">
                        <strong>üí° Rate Limits:</strong> NASA API allows 1000 requests/hour with free key. NOAA SWPC data updates every minute.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script>
        let scene, camera, renderer, sun, earth, moon;
        let particles = [];
        let cmeParticles = [];
        let solarWindChart;
        let lastNASAUpdate = null;
        let currentKp = 2.3;
        let auroraActive = false;
        
        // NASA API Configuration - Professional Grade
        const NASA_API_KEY = 'DEMO_KEY'; // Replace with your NASA API key
        const DONKI_BASE_URL = 'https://api.nasa.gov/DONKI';
        const NOAA_SWPC_BASE = 'https://services.swpc.noaa.gov/products';
        const ACE_REAL_TIME = 'https://services.swpc.noaa.gov/products/solar-wind';
        
        // Scientific Constants
        const EARTH_RADIUS = 6371; // km
        const AU_TO_KM = 149597870.7; // Astronomical Unit in km
        const SOLAR_RADIUS = 695700; // km
        const EARTH_MAGNETIC_MOMENT = 7.906e15; // Tesla‚ãÖm¬≥
        
        // Professional Space Weather Data Storage
        let spaceWeatherData = {
            cmes: [],
            flares: [],
            geoStorms: [],
            solarWind: [],
            kpIndex: [],
            dstIndex: [],
            solarWindSpeed: [],
            protonFlux: [],
            xrayFlux: []
        };
        
        // Scientific Analysis Variables
        let magneticFieldModel = null;
        let solarWindParameters = {
            speed: 400, // km/s
            density: 5, // particles/cm¬≥
            temperature: 100000, // Kelvin
            bField: 5, // nT
            pressure: 2.5 // nPa
        };
        
        function init() {
            setupScene();
            setupChart();
            loadNASAData();
            updateTime();
            setInterval(updateTime, 1000);
            setInterval(autoUpdateData, 300000); // Update every 5 minutes
            setInterval(performSpaceWeatherAnalysis, 30000); // Run analysis every 30 seconds, not every frame
            animate();
        }
        
        function setupScene() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000814, 50, 200);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 30);
            camera.lookAt(0, 0, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000814, 0);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);
            
            const sunLight = new THREE.PointLight(0xffa500, 2, 100);
            sunLight.position.set(0, 0, 0);
            sunLight.castShadow = true;
            scene.add(sunLight);
            
            // Sun with corona effect
            const sunGeometry = new THREE.SphereGeometry(2.5, 64, 64);
            const sunMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    void main() {
                        float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                        vec3 color = mix(vec3(1.0, 0.3, 0.0), vec3(1.0, 0.8, 0.0), intensity);
                        float flicker = 0.8 + 0.2 * sin(time * 3.0 + vPosition.x * 5.0);
                        gl_FragColor = vec4(color * flicker, 1.0);
                    }
                `,
                side: THREE.DoubleSide
            });
            sun = new THREE.Mesh(sunGeometry, sunMaterial);
            scene.add(sun);
            
            // Earth with realistic materials
            const earthGeometry = new THREE.SphereGeometry(1, 64, 64);
            const earthMaterial = new THREE.MeshPhongMaterial({
                color: 0x2244aa,
                shininess: 30,
                specular: 0x222222
            });
            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            earth.position.set(20, 0, 0);
            earth.castShadow = true;
            earth.receiveShadow = true;
            scene.add(earth);
            
            // Moon
            const moonGeometry = new THREE.SphereGeometry(0.27, 32, 32);
            const moonMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
            moon = new THREE.Mesh(moonGeometry, moonMaterial);
            moon.position.set(22, 0, 0);
            scene.add(moon);
            
            // Add starfield
            createStarField();
            
            // Add orbital paths
            createOrbitalPaths();
        }
        
        function createStarField() {
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 });
            
            const starVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starVertices.push(x, y, z);
            }
            
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }
        
        function createOrbitalPaths() {
            // Earth orbit - enhanced visibility
            const earthOrbitGeometry = new THREE.RingGeometry(17.9, 18.1, 128);
            const earthOrbitMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ddff,
                opacity: 0.5,
                transparent: true,
                side: THREE.DoubleSide
            });
            const earthOrbit = new THREE.Mesh(earthOrbitGeometry, earthOrbitMaterial);
            earthOrbit.rotation.x = Math.PI / 2;
            scene.add(earthOrbit);
            
            // Add orbital position indicator for Earth
            const earthIndicatorGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const earthIndicatorMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8
            });
            window.earthIndicator = new THREE.Mesh(earthIndicatorGeometry, earthIndicatorMaterial);
            scene.add(window.earthIndicator);
            
            // Create dynamic Moon orbital path - enhanced visibility
            window.moonOrbitPoints = [];
            const moonOrbitGeometry = new THREE.BufferGeometry();
            const moonOrbitMaterial = new THREE.LineBasicMaterial({
                color: 0xcccccc,
                transparent: true,
                opacity: 0.6,
                linewidth: 2
            });
            window.moonOrbitLine = new THREE.Line(moonOrbitGeometry, moonOrbitMaterial);
            scene.add(window.moonOrbitLine);
        }
        
        function setupChart() {
            const ctx = document.getElementById('chart-canvas').getContext('2d');
            solarWindChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: Array.from({length: 24}, (_, i) => `${i}:00`),
                    datasets: [{
                        label: 'Solar Wind Speed (km/s)',
                        data: generateSolarWindData(),
                        borderColor: '#00aaff',
                        backgroundColor: 'rgba(0, 170, 255, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: { display: false },
                        y: {
                            display: true,
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: '#aaccff', font: { size: 10 } }
                        }
                    }
                }
            });
        }
        
        function generateSolarWindData() {
            return Array.from({length: 24}, () => 350 + Math.random() * 300);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            
            // Update sun shader time for dynamic effects
            if (sun.material.uniforms) {
                sun.material.uniforms.time.value = time;
            }
            
            // Sun rotation (smooth and steady)
            sun.rotation.y += 0.01;
            
            // Earth orbit around Sun - tight, circular, precise
            const earthOrbitSpeed = 0.05; // Faster, more visible orbital motion
            const earthOrbitRadius = 18; // Tighter orbit
            const earthAngle = time * earthOrbitSpeed;
            
            // Perfect circular orbit around Sun (at origin)
            earth.position.x = Math.cos(earthAngle) * earthOrbitRadius;
            earth.position.z = Math.sin(earthAngle) * earthOrbitRadius;
            earth.position.y = 0; // Keep on orbital plane
            
            // Earth rotation on its axis (faster for visual effect)
            earth.rotation.y += 0.03;
            
            // Moon orbit around Earth - tight and stable
            const moonOrbitSpeed = 0.3; // Faster moon orbit for visibility
            const moonDistance = 2.2; // Closer to Earth for tighter orbit
            const moonAngle = time * moonOrbitSpeed;
            
            // Moon orbits Earth in Earth's local coordinate system
            moon.position.x = earth.position.x + Math.cos(moonAngle) * moonDistance;
            moon.position.z = earth.position.z + Math.sin(moonAngle) * moonDistance;
            moon.position.y = earth.position.y; // Same orbital plane as Earth
            
            // Moon rotation (tidally locked to Earth)
            moon.rotation.y = moonAngle;
            
            // Update orbital indicators
            if (window.earthIndicator) {
                window.earthIndicator.position.copy(earth.position);
                window.earthIndicator.position.y += 0.2; // Slightly above Earth
            }
            
            // Update dynamic Moon orbital path
            if (window.moonOrbitPoints && window.moonOrbitLine) {
                // Add current Moon position to trail
                window.moonOrbitPoints.push(moon.position.clone());
                
                // Keep only last 100 points for performance
                if (window.moonOrbitPoints.length > 100) {
                    window.moonOrbitPoints.shift();
                }
                
                // Update the line geometry
                const positions = new Float32Array(window.moonOrbitPoints.length * 3);
                for (let i = 0; i < window.moonOrbitPoints.length; i++) {
                    positions[i * 3] = window.moonOrbitPoints[i].x;
                    positions[i * 3 + 1] = window.moonOrbitPoints[i].y;
                    positions[i * 3 + 2] = window.moonOrbitPoints[i].z;
                }
                window.moonOrbitLine.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                window.moonOrbitLine.geometry.attributes.position.needsUpdate = true;
            }
            
            // Update CME particles with realistic solar wind physics
            cmeParticles.forEach((particle, i) => {
                // Calculate distance from Sun (at origin)
                const distanceFromSun = particle.position.length();
                
                // Solar wind acceleration (1/r¬≤ law)
                const solarWindAcceleration = 0.015 / Math.max(distanceFromSun * distanceFromSun, 1);
                const directionFromSun = particle.position.clone().normalize();
                
                // Apply solar wind force
                particle.velocity.add(directionFromSun.multiplyScalar(solarWindAcceleration));
                
                // Update position
                particle.position.add(particle.velocity);
                
                // Add slight turbulence for realism
                particle.position.add(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.02,
                    (Math.random() - 0.5) * 0.02,
                    (Math.random() - 0.5) * 0.02
                ));
                
                // Remove particles that are too far from the solar system
                if (distanceFromSun > 100) {
                    scene.remove(particle);
                    cmeParticles.splice(i, 1);
                    return;
                }
                
                // Check Earth interaction (with Earth's magnetosphere)
                const earthDistance = particle.position.distanceTo(earth.position);
                if (earthDistance < 2.5) { // Earth + magnetosphere
                    // Create aurora effect
                    triggerAuroraEffect();
                    
                    // Some particles are deflected, some absorbed
                    if (Math.random() < 0.7) {
                        // Deflect particle around Earth's magnetosphere
                        const deflectionAngle = Math.random() * Math.PI * 2;
                        particle.velocity.x = Math.cos(deflectionAngle) * 0.1;
                        particle.velocity.z = Math.sin(deflectionAngle) * 0.1;
                        particle.velocity.y = (Math.random() - 0.5) * 0.1;
                    } else {
                        // Absorb particle
                        scene.remove(particle);
                        cmeParticles.splice(i, 1);
                    }
                }
            });
            
            // Update regular solar wind particles (continuous emission)
            particles.forEach((particle, i) => {
                // Similar physics but weaker
                const distanceFromSun = particle.position.length();
                const solarWindForce = 0.008 / Math.max(distanceFromSun, 1);
                const direction = particle.position.clone().normalize();
                
                particle.velocity.add(direction.multiplyScalar(solarWindForce));
                particle.position.add(particle.velocity);
                
                // Remove distant particles
                if (distanceFromSun > 80) {
                    scene.remove(particle);
                    particles.splice(i, 1);
                }
            });
            
            // Continuously emit solar wind particles from Sun with count management
            if (particles.length < 200 && Math.random() < 0.08) { // Limit particles and reduce frequency
                createSolarWindParticle();
            }
            
            // Clean up excess CME particles for performance
            if (cmeParticles.length > 500) {
                const particlesToRemove = cmeParticles.splice(0, 100);
                particlesToRemove.forEach(particle => {
                    scene.remove(particle);
                });
            }
            
            renderer.render(scene, camera);
        }
        
        // Create continuous solar wind - tightened to exact Sun surface
        function createSolarWindParticle() {
            const geometry = new THREE.SphereGeometry(0.015, 6, 6);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xffaa44,
                transparent: true,
                opacity: 0.6
            });
            const particle = new THREE.Mesh(geometry, material);
            
            // Emanate exactly from Sun surface (radius 2.5)
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const sunRadius = 2.5; // Exact Sun surface
            
            particle.position.set(
                sunRadius * Math.sin(phi) * Math.cos(theta),
                sunRadius * Math.sin(phi) * Math.sin(theta),
                sunRadius * Math.cos(phi)
            );
            
            // Initial velocity outward - more consistent speed
            const direction = particle.position.clone().normalize();
            particle.velocity = direction.multiplyScalar(0.06); // Consistent solar wind speed
            
            scene.add(particle);
            particles.push(particle);
        }
        
        // Scientific Solar Physics Models
        function calculateCMEArrivalTime(cmeData) {
            // Drag-Based Model (DBM) for CME propagation
            const initialSpeed = cmeData.speed || 500; // km/s
            const solarWindSpeed = solarWindParameters.speed; // km/s
            const dragParameter = 0.2e-6; // per km
            const distanceToEarth = AU_TO_KM; // km
            
            // DBM equation: v(t) = vf + (v0 - vf) * exp(-Œ≥t)
            const finalSpeed = solarWindSpeed;
            const gamma = dragParameter * solarWindSpeed;
            
            // Solve for arrival time
            const arrivalTime = -Math.log((finalSpeed - solarWindSpeed) / (initialSpeed - solarWindSpeed)) / gamma;
            return arrivalTime / 3600; // Convert to hours
        }
        
        function calculateKpFromSolarWind(speed, bz, density) {
            // Empirical formula for Kp index prediction
            // Based on Burton et al. (1975) and Newell et al. (2007)
            const vbs = speed * Math.abs(bz) * Math.sqrt(density);
            const coupling = Math.pow(vbs, 2/3);
            
            let kp = 0;
            if (coupling < 0.5) kp = 0;
            else if (coupling < 1.0) kp = 1;
            else if (coupling < 2.0) kp = 2;
            else if (coupling < 4.0) kp = 3;
            else if (coupling < 6.0) kp = 4;
            else if (coupling < 9.0) kp = 5;
            else if (coupling < 12.0) kp = 6;
            else if (coupling < 15.0) kp = 7;
            else if (coupling < 20.0) kp = 8;
            else kp = 9;
            
            return Math.min(kp, 9);
        }
        
        function calculateDstIndex(speed, bz, density, pressure) {
            // Empirical Dst prediction formula
            // Based on Burton et al. (1975) and O'Brien & McPherron (2000)
            const ey = speed * Math.abs(bz) * 1e-3; // Electric field
            const injectionRate = -4.4 * (ey - 0.49);
            const decayRate = 2.4e-6; // per second
            
            // Simplified Dst calculation
            let dst = -50 * Math.log10(pressure + 1) + injectionRate;
            return Math.max(dst, -400); // Cap at extreme values
        }
        
        function calculateAuroralOval(kp) {
            // Auroral oval latitude calculation based on Kp index
            // From Holzworth & Meng (1975)
            const quietLatitude = 67; // degrees
            const expansion = 2.5 * kp; // degrees per Kp unit
            const auroralLatitude = quietLatitude - expansion;
            
            return {
                latitude: Math.max(auroralLatitude, 50), // Don't go below 50¬∞
                width: 3 + 0.5 * kp, // Oval width in degrees
                intensity: kp / 9 // Normalized intensity
            };
        }
        
        // Advanced NASA API Integration Functions
        async function loadNASAData() {
            logMessage('Synchronizing with NASA DONKI and NOAA SWPC...', 'normal');
            
            try {
                const endDate = new Date().toISOString().split('T')[0];
                const startDate = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
                
                // Parallel data loading for efficiency
                const [cmeData, flareData, geoStormData, solarWindData] = await Promise.all([
                    loadCMEData(startDate, endDate),
                    loadFlareData(startDate, endDate),
                    loadGeoStormData(startDate, endDate),
                    loadRealTimeSolarWind()
                ]);
                
                // Scientific analysis of loaded data
                performSpaceWeatherAnalysis();
                updateDisplayFromNASAData();
                lastNASAUpdate = new Date();
                logMessage('Professional space weather analysis complete', 'success');
                
            } catch (error) {
                logMessage('API connection failed - using simulated data', 'warning');
                generateSimulatedData();
            }
        }
        
        async function loadRealTimeSolarWind() {
            try {
                const response = await fetch(`${ACE_REAL_TIME}/ace-swepam.json`);
                if (response.ok) {
                    const data = await response.json();
                    processSolarWindData(data);
                }
            } catch (error) {
                console.log('Real-time solar wind data unavailable');
            }
        }
        
        function processSolarWindData(data) {
            if (data && data.length > 0) {
                const latest = data[data.length - 1];
                solarWindParameters.speed = parseFloat(latest.vx) || 400;
                solarWindParameters.density = parseFloat(latest.np) || 5;
                solarWindParameters.temperature = parseFloat(latest.tp) || 100000;
                
                // Calculate derived parameters
                const dynamicPressure = 1.6726e-6 * solarWindParameters.density * 
                                       Math.pow(solarWindParameters.speed, 2); // nPa
                solarWindParameters.pressure = dynamicPressure;
                
                logMessage(`Real-time solar wind: ${solarWindParameters.speed.toFixed(0)} km/s`, 'success');
            }
        }
        
        function performSpaceWeatherAnalysis() {
            // Perform comprehensive space weather analysis
            const currentBz = -2; // Simplified - would come from real data
            const predictedKp = calculateKpFromSolarWind(
                solarWindParameters.speed,
                currentBz,
                solarWindParameters.density
            );
            
            const predictedDst = calculateDstIndex(
                solarWindParameters.speed,
                currentBz,
                solarWindParameters.density,
                solarWindParameters.pressure
            );
            
            const auroralData = calculateAuroralOval(predictedKp);
            
            // Update scientific parameters
            currentKp = predictedKp;
            
            // Update professional display with scientific parameters
            updateStatusValue('kp', predictedKp.toFixed(1));
            updateStatusValue('dst-index', `${predictedDst.toFixed(0)} nT`);
            updateStatusValue('aurora-lat', `${auroralData.latitude.toFixed(1)}¬∞`);
            updateStatusValue('bz-field', `${currentBz.toFixed(1)} nT`);
            updateStatusValue('sw-pressure', `${solarWindParameters.pressure.toFixed(1)} nPa`);
            updateStatusValue('wind', `${solarWindParameters.speed.toFixed(0)} km/s`);
            
            // Calculate and display CME arrivals
            const cmeArrivals = calculateCMEArrivals();
            updateStatusValue('cme-arrivals', `${cmeArrivals.length} Predicted`);
            
            // Update solar activity classification
            let activityLevel = 'Quiet';
            if (predictedKp >= 5) activityLevel = 'Storm';
            else if (predictedKp >= 4) activityLevel = 'Active';
            else if (predictedKp >= 3) activityLevel = 'Unsettled';
            updateStatusValue('solar', activityLevel);
            
            // Update aurora monitoring system with new data
            updateAuroraMonitoring();
            
            // Log scientific findings with proper units
            logMessage(`Scientific Analysis: Kp=${predictedKp.toFixed(1)}, Dst=${predictedDst.toFixed(0)}nT, Bz=${currentBz.toFixed(1)}nT`, 'normal');
            logMessage(`Auroral oval at ${auroralData.latitude.toFixed(1)}¬∞ magnetic latitude`, 'normal');
            logMessage(`Solar wind: v=${solarWindParameters.speed.toFixed(0)}km/s, n=${solarWindParameters.density.toFixed(1)}/cm¬≥`, 'normal');
        }
        
        async function loadCMEData(startDate, endDate) {
            const response = await fetch(`${DONKI_BASE_URL}/CME?startDate=${startDate}&endDate=${endDate}&api_key=${NASA_API_KEY}`);
            if (response.ok) {
                spaceWeatherData.cmes = await response.json();
            }
        }
        
        async function loadFlareData(startDate, endDate) {
            const response = await fetch(`${DONKI_BASE_URL}/FLR?startDate=${startDate}&endDate=${endDate}&api_key=${NASA_API_KEY}`);
            if (response.ok) {
                spaceWeatherData.flares = await response.json();
            }
        }
        
        async function loadGeoStormData(startDate, endDate) {
            const response = await fetch(`${DONKI_BASE_URL}/GST?startDate=${startDate}&endDate=${endDate}&api_key=${NASA_API_KEY}`);
            if (response.ok) {
                spaceWeatherData.geoStorms = await response.json();
            }
        }
        
        function updateDisplayFromNASAData() {
            // Update CME count
            const activeCMEs = spaceWeatherData.cmes.filter(cme => {
                const eventTime = new Date(cme.activityID);
                const now = new Date();
                return (now - eventTime) < 3 * 24 * 60 * 60 * 1000; // 3 days
            });
            document.getElementById('cme').textContent = `${activeCMEs.length} Recent`;
            
            // Update solar activity based on flare data
            const recentFlares = spaceWeatherData.flares.filter(flare => {
                const eventTime = new Date(flare.beginTime);
                const now = new Date();
                return (now - eventTime) < 24 * 60 * 60 * 1000; // 24 hours
            });
            
            let activityLevel = 'Low';
            if (recentFlares.length > 5) activityLevel = 'High';
            else if (recentFlares.length > 2) activityLevel = 'Moderate';
            
            updateStatusValue('solar', activityLevel);
            
            // Calculate Kp index from geomagnetic storms
            if (spaceWeatherData.geoStorms.length > 0) {
                const latestStorm = spaceWeatherData.geoStorms[spaceWeatherData.geoStorms.length - 1];
                if (latestStorm.allKpIndex && latestStorm.allKpIndex.length > 0) {
                    const latestKp = latestStorm.allKpIndex[latestStorm.allKpIndex.length - 1];
                    currentKp = parseFloat(latestKp.kpIndex) || currentKp;
                    updateStatusValue('kp', currentKp.toFixed(1));
                }
            }
            
            updateAuroraProbability();
        }
        
        function generateSimulatedData() {
            // Generate realistic simulated data when NASA API is unavailable
            currentKp = 1.5 + Math.random() * 3;
            const windSpeed = 350 + Math.random() * 200;
            const cmeCount = Math.floor(Math.random() * 3);
            
            updateStatusValue('kp', currentKp.toFixed(1));
            updateStatusValue('wind', `${Math.floor(windSpeed)} km/s`);
            updateStatusValue('cme', `${cmeCount} Recent`);
            updateStatusValue('data-status', 'Simulated');
            
            updateAuroraProbability();
        }
        
        function updateStatusValue(id, value) {
            const element = document.getElementById(id);
            if (element) {
                element.textContent = value;
                
                // Update status colors based on Kp index
                if (id === 'kp') {
                    const kpValue = parseFloat(value);
                    element.className = 'status-value ' + 
                        (kpValue >= 5 ? 'critical' : kpValue >= 3 ? 'warning' : 'normal');
                }
            }
        }
        
        function updateAuroraProbability() {
            let probability = Math.max(0, (currentKp - 1) * 20);
            probability = Math.min(100, probability);
            
            updateStatusValue('aurora-prob', `${Math.floor(probability)}%`);
            
            // Update Kp visualization
            updateKpVisualization();
        }
        
        function updateKpVisualization() {
            const kpBars = document.querySelectorAll('.kp-bar');
            kpBars.forEach((bar, index) => {
                const height = Math.max(2, Math.min(35, (currentKp - index) * 10));
                bar.style.height = `${height}px`;
                
                if (currentKp > index) {
                    bar.style.opacity = '1';
                } else {
                    bar.style.opacity = '0.3';
                }
            });
        }
        
        // Interactive Functions
        function simulateCME() {
            logMessage('Simulating CME event with physics-based particles...', 'warning');
            
            // Clear existing CME particles first for better performance
            cmeParticles.forEach(particle => scene.remove(particle));
            cmeParticles.length = 0;
            
            // Create realistic CME particle burst - directed cone toward Earth
            const earthDirection = earth.position.clone().normalize();
            
            for (let i = 0; i < 600; i++) { // Reduced count for better performance
                const geometry = new THREE.SphereGeometry(0.03 + Math.random() * 0.07, 8, 8);
                
                // CME particles have more orange/red colors
                const hue = 0.05 + Math.random() * 0.15; // Orange to red
                const saturation = 0.8 + Math.random() * 0.2;
                const lightness = 0.4 + Math.random() * 0.4;
                const color = new THREE.Color().setHSL(hue, saturation, lightness);
                
                const material = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.6 + Math.random() * 0.4
                });
                const particle = new THREE.Mesh(geometry, material);
                
                // Emanate from Sun surface in a cone toward Earth
                const coneAngle = Math.PI / 6; // 30-degree cone
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(1 - Math.random() * (1 - Math.cos(coneAngle)));
                
                // Base direction toward Earth with cone spread
                const baseDirection = earthDirection.clone();
                const perpVector1 = new THREE.Vector3(1, 0, 0).cross(baseDirection).normalize();
                const perpVector2 = baseDirection.clone().cross(perpVector1).normalize();
                
                const coneDirection = baseDirection.clone()
                    .add(perpVector1.clone().multiplyScalar(Math.sin(phi) * Math.cos(theta)))
                    .add(perpVector2.clone().multiplyScalar(Math.sin(phi) * Math.sin(theta)))
                    .normalize();
                
                // Position exactly on Sun surface (tightened)
                const sunRadius = 2.5; // Exact Sun surface
                particle.position.copy(coneDirection.clone().multiplyScalar(sunRadius));
                
                // Velocity in cone direction - more concentrated
                const speed = 0.2 + Math.random() * 0.15; // Tighter speed range
                particle.velocity = coneDirection.clone().multiplyScalar(speed);
                
                // Reduced randomness for tighter particle stream
                particle.velocity.add(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.04,
                    (Math.random() - 0.5) * 0.04,
                    (Math.random() - 0.5) * 0.04
                ));
                
                scene.add(particle);
                cmeParticles.push(particle);
            }
            
            // Also create some background CME particles in other directions
            for (let i = 0; i < 100; i++) { // Reduced for performance
                const geometry = new THREE.SphereGeometry(0.02 + Math.random() * 0.05, 6, 6);
                const color = new THREE.Color().setHSL(0.1 + Math.random() * 0.1, 0.7, 0.5);
                const material = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.3
                });
                const particle = new THREE.Mesh(geometry, material);
                
                // Random direction from Sun
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const radius = 2.6;
                
                particle.position.set(
                    radius * Math.sin(phi) * Math.cos(theta),
                    radius * Math.sin(phi) * Math.sin(theta),
                    radius * Math.cos(phi)
                );
                
                const direction = particle.position.clone().normalize();
                particle.velocity = direction.multiplyScalar(0.08 + Math.random() * 0.12);
                
                scene.add(particle);
                cmeParticles.push(particle);
            }
            
            // Update display
            currentKp = Math.min(9, currentKp + 1.5 + Math.random() * 2);
            updateStatusValue('cme', '1 Active');
            updateStatusValue('solar', 'Severe');
            updateAuroraProbability();
            updateKpVisualization();
            updateAuroraMonitoring(); // Update aurora monitor with new Kp
            
            logMessage('Directed CME launched toward Earth - impact expected in 18-72 hours', 'error');
        }
        
        function analyzeWeather() {
            logMessage('Performing comprehensive space weather analysis...', 'normal');
            
            // Advanced analysis with multiple parameters
            const kp = Math.max(0, Math.min(9, currentKp + (Math.random() - 0.5) * 0.5));
            const wind = Math.floor(350 + Math.random() * 300);
            const density = (2 + Math.random() * 8).toFixed(1);
            const magneticField = (3 + Math.random() * 12).toFixed(1);
            
            updateStatusValue('kp', kp.toFixed(1));
            updateStatusValue('wind', wind + ' km/s');
            
            // Determine activity level
            let activityLevel = 'Low';
            if (kp >= 5) activityLevel = 'Severe';
            else if (kp >= 4) activityLevel = 'High';
            else if (kp >= 3) activityLevel = 'Moderate';
            
            updateStatusValue('solar', activityLevel);
            currentKp = kp;
            updateAuroraProbability();
            updateKpVisualization();
            updateAuroraMonitoring(); // Update aurora monitor with new analysis
            
            // Update chart with new data
            solarWindChart.data.datasets[0].data = generateSolarWindData();
            solarWindChart.update();
            
            logMessage(`Analysis complete: Kp=${kp.toFixed(1)}, Wind=${wind}km/s, Activity=${activityLevel}`, 'success');
        }
        
        function generateForecast() {
            logMessage('Generating 24-hour geomagnetic forecast...', 'normal');
            
            // Advanced forecasting based on current conditions
            const forecasts = {
                low: [
                    'Quiet geomagnetic conditions expected. Aurora visible at high latitudes only.',
                    'Minimal space weather activity. Normal satellite operations.',
                    'Stable solar wind conditions. No significant aurora activity.'
                ],
                moderate: [
                    'Minor geomagnetic storm possible. Aurora may be visible down to 60¬∞ latitude.',
                    'Active conditions developing. Increased aurora probability.',
                    'Moderate solar wind enhancement. Minor HF radio impacts possible.'
                ],
                high: [
                    'Major geomagnetic storm likely. Aurora visible down to 50¬∞ latitude.',
                    'Severe space weather conditions. Satellite operations may be affected.',
                    'Strong solar wind disturbance. Significant HF radio disruption expected.'
                ]
            };
            
            let category = 'low';
            if (currentKp >= 5) category = 'high';
            else if (currentKp >= 3) category = 'moderate';
            
            const forecast = forecasts[category][Math.floor(Math.random() * forecasts[category].length)];
            
            // Update forecast panel
            const content = document.getElementById('forecast-content');
            const condition = currentKp >= 5 ? 'Severe' : currentKp >= 3 ? 'Active' : 'Quiet';
            const conditionColor = currentKp >= 5 ? '#ff4444' : currentKp >= 3 ? '#ffaa44' : '#44ff88';
            
            content.innerHTML = `
                <div style="margin: 10px 0; font-size: 13px; color: #aaccff;">
                    Geomagnetic Conditions: <strong style="color: ${conditionColor};">${condition}</strong>
                </div>
                <div style="margin: 10px 0; font-size: 13px; color: #aaccff;">
                    Aurora Probability: <strong style="color: #ffaa44;">${Math.floor((currentKp - 1) * 20)}%</strong>
                </div>
                <div style="margin: 10px 0; font-size: 12px; color: #cccccc;">
                    ${forecast}
                </div>
                <div style="margin: 10px 0; font-size: 12px; color: #888;">
                    Generated: <span id="forecast-generated">${new Date().toLocaleTimeString()}</span>
                </div>
            `;
            
            logMessage('24-hour forecast generated and updated', 'success');
        }
        
        async function autoUpdateData() {
            logMessage('Auto-updating space weather data...', 'normal');
            await loadNASAData();
        }
        
        // Professional Aurora Monitoring System
        let auroraIntensity = 0; // 0-4 scale
        let auroraVisibility = [];
        
        function toggleAurora() {
            auroraActive = !auroraActive;
            updateAuroraMonitoring();
            
            if (auroraActive) {
                logMessage('Professional aurora monitoring activated', 'success');
                logMessage(`Current aurora level: ${getAuroraLevelName(auroraIntensity)}`, 'normal');
            } else {
                logMessage('Aurora monitoring deactivated', 'normal');
            }
        }
        
        function updateAuroraMonitoring() {
            // Calculate professional aurora intensity based on Kp index
            auroraIntensity = calculateAuroraIntensity(currentKp);
            auroraVisibility = getAuroraVisibilityRegions(currentKp);
            
            // Update button display
            const statusText = document.getElementById('aurora-status');
            const button = document.getElementById('aurora-monitor-btn');
            const levelName = getAuroraLevelName(auroraIntensity);
            
            statusText.textContent = `Aurora: ${levelName}`;
            
            // Color-code button based on intensity
            if (auroraIntensity === 0) {
                button.style.background = 'linear-gradient(135deg, #004466 0%, #002244 100%)'; // Blue (quiet)
            } else if (auroraIntensity === 1) {
                button.style.background = 'linear-gradient(135deg, #006600 0%, #004400 100%)'; // Green (minor)
            } else if (auroraIntensity === 2) {
                button.style.background = 'linear-gradient(135deg, #ffaa00 0%, #cc6600 100%)'; // Orange (moderate)
            } else if (auroraIntensity === 3) {
                button.style.background = 'linear-gradient(135deg, #ff6600 0%, #cc3300 100%)'; // Red (active)
            } else {
                button.style.background = 'linear-gradient(135deg, #cc0066 0%, #660033 100%)'; // Purple (severe)
            }
            
            // Update visual aurora effects
            updateAuroraVisualEffects();
            
            // Update status display
            updateStatusValue('aurora-lat', `${calculateAuroralOval(currentKp).latitude.toFixed(1)}¬∞`);
            
            // Log professional aurora information
            if (auroraActive) {
                logMessage(`Aurora visible in: ${auroraVisibility.join(', ')}`, 'normal');
                logMessage(`Kp=${currentKp.toFixed(1)}, Intensity=${levelName}, Latitude=${calculateAuroralOval(currentKp).latitude.toFixed(1)}¬∞`, 'normal');
            }
        }
        
        function calculateAuroraIntensity(kp) {
            // Professional 5-level aurora intensity scale
            if (kp < 1) return 0; // Quiet
            if (kp < 2.5) return 1; // Minor
            if (kp < 4) return 2; // Moderate  
            if (kp < 6) return 3; // Active
            return 4; // Severe
        }
        
        function getAuroraLevelName(intensity) {
            const levels = ['QUIET', 'MINOR', 'MODERATE', 'ACTIVE', 'SEVERE'];
            return levels[intensity];
        }
        
        function getAuroraVisibilityRegions(kp) {
            // Professional aurora visibility calculation
            const auroralData = calculateAuroralOval(kp);
            return getAuroraLocations(auroralData.latitude);
        }
        
        function updateAuroraVisualEffects() {
            const auroraElement = document.getElementById('aurora');
            
            if (!auroraActive) {
                auroraElement.classList.remove('aurora-active');
                auroraElement.style.background = '';
                return;
            }
            
            // Professional aurora colors based on intensity
            let auroraColors;
            if (auroraIntensity === 0) {
                auroraColors = 'rgba(0, 0, 0, 0)'; // No aurora
            } else if (auroraIntensity === 1) {
                auroraColors = 'radial-gradient(ellipse at center, rgba(0, 255, 100, 0.2) 0%, transparent 70%)'; // Green
            } else if (auroraIntensity === 2) {
                auroraColors = 'radial-gradient(ellipse at center, rgba(0, 255, 100, 0.3) 0%, rgba(255, 255, 0, 0.2) 40%, transparent 70%)'; // Green + Yellow
            } else if (auroraIntensity === 3) {
                auroraColors = 'radial-gradient(ellipse at center, rgba(255, 0, 100, 0.3) 0%, rgba(0, 255, 100, 0.4) 30%, rgba(255, 255, 0, 0.2) 60%, transparent 80%)'; // Red + Green + Yellow
            } else {
                auroraColors = 'radial-gradient(ellipse at center, rgba(200, 0, 255, 0.4) 0%, rgba(255, 0, 100, 0.3) 25%, rgba(0, 255, 100, 0.4) 50%, rgba(255, 255, 0, 0.2) 75%, transparent 90%)'; // Purple + Red + Green + Yellow
            }
            
            auroraElement.classList.add('aurora-active');
            auroraElement.style.background = auroraColors;
            auroraElement.style.opacity = auroraIntensity > 0 ? (0.3 + auroraIntensity * 0.2) : 0;
        }
        
        function triggerAuroraEffect() {
            const auroraElement = document.getElementById('aurora');
            auroraElement.classList.add('aurora-active');
            
            setTimeout(() => {
                auroraElement.classList.remove('aurora-active');
            }, 5000);
            
            logMessage('Aurora event detected! Earth magnetosphere interaction', 'success');
        }
        
        function exportData() {
            // Professional scientific data export in multiple formats
            const scientificData = {
                metadata: {
                    title: "Space Weather Observatory Analysis",
                    version: "2.0.0",
                    timestamp: new Date().toISOString(),
                    source: "NASA DONKI, NOAA SWPC",
                    coordinate_system: "GSE",
                    units: {
                        speed: "km/s",
                        density: "particles/cm¬≥",
                        magnetic_field: "nT",
                        pressure: "nPa",
                        temperature: "K"
                    }
                },
                current_conditions: {
                    kp_index: currentKp,
                    solar_wind: solarWindParameters,
                    magnetic_field: {
                        bx: 0, by: 0, bz: -2, // Would be real data
                        total: Math.sqrt(4) // |B|
                    },
                    dst_index: calculateDstIndex(
                        solarWindParameters.speed, -2,
                        solarWindParameters.density,
                        solarWindParameters.pressure
                    ),
                    auroral_oval: calculateAuroralOval(currentKp)
                },
                raw_data: spaceWeatherData,
                predictions: {
                    next_24h_kp: generateKpForecast(),
                    cme_arrivals: calculateCMEArrivals(),
                    aurora_forecast: generateAuroraForecast()
                },
                scientific_references: [
                    "Burton et al. (1975) - Dst prediction model",
                    "Newell et al. (2007) - Kp coupling function",
                    "Holzworth & Meng (1975) - Auroral oval model",
                    "O'Brien & McPherron (2000) - Ring current model"
                ]
            };
            
            // Export as NASA-standard JSON format
            const blob = new Blob([JSON.stringify(scientificData, null, 2)], { 
                type: 'application/json' 
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `space_weather_scientific_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            logMessage('Scientific data exported in NASA-compatible format', 'success');
        }
        
        function generateKpForecast() {
            // 24-hour Kp forecast using physical models
            const forecast = [];
            const baseKp = currentKp;
            
            for (let hour = 0; hour < 24; hour++) {
                // Simple decay model with CME enhancement
                let kp = baseKp * Math.exp(-hour * 0.1);
                
                // Add CME impact if predicted
                if (hour >= 18 && hour <= 30) { // 18-30 hour arrival window
                    kp += 2; // CME enhancement
                }
                
                forecast.push({
                    hour: hour,
                    kp_predicted: Math.min(Math.max(kp, 0), 9),
                    confidence: Math.max(0.9 - hour * 0.02, 0.3) // Decreasing confidence
                });
            }
            
            return forecast;
        }
        
        function calculateCMEArrivals() {
            // Calculate predicted CME arrival times using physics
            const arrivals = [];
            
            spaceWeatherData.cmes.forEach(cme => {
                if (cme.speed && cme.speed > 300) {
                    const arrivalTime = calculateCMEArrivalTime(cme);
                    const eventTime = new Date(cme.activityID);
                    const arrivalDate = new Date(eventTime.getTime() + arrivalTime * 3600000);
                    
                    arrivals.push({
                        cme_id: cme.activityID,
                        launch_time: eventTime.toISOString(),
                        predicted_arrival: arrivalDate.toISOString(),
                        travel_time_hours: arrivalTime,
                        initial_speed: cme.speed,
                        impact_probability: 0.7 // Would be calculated from CME width/direction
                    });
                }
            });
            
            return arrivals;
        }
        
        function generateAuroraForecast() {
            // Scientific aurora forecast based on Kp predictions
            const auroraForecast = [];
            const kpForecast = generateKpForecast();
            
            kpForecast.forEach(prediction => {
                const auroralData = calculateAuroralOval(prediction.kp_predicted);
                
                auroraForecast.push({
                    hour: prediction.hour,
                    auroral_latitude: auroralData.latitude,
                    visibility_locations: getAuroraLocations(auroralData.latitude),
                    intensity: auroralData.intensity,
                    colors: getAuroraColors(prediction.kp_predicted)
                });
            });
            
            return auroraForecast;
        }
        
        function getAuroraLocations(latitude) {
            // Return locations where aurora would be visible
            if (latitude <= 50) return ["Northern Canada", "Alaska", "Northern Scandinavia", "Northern Russia", "Northern Scotland"];
            if (latitude <= 55) return ["Northern Canada", "Alaska", "Northern Scandinavia", "Northern Russia"];
            if (latitude <= 60) return ["Northern Canada", "Alaska", "Northern Scandinavia"];
            if (latitude <= 65) return ["Northern Canada", "Alaska"];
            return ["High Arctic only"];
        }
        
        function getAuroraColors(kp) {
            // Aurora color prediction based on Kp intensity
            if (kp < 2) return ["Green (weak)"];
            if (kp < 4) return ["Green", "Yellow"];
            if (kp < 6) return ["Green", "Yellow", "Red"];
            return ["Green", "Yellow", "Red", "Purple", "Blue"];
        }
        
        function logMessage(message, type = 'normal') {
            const log = document.getElementById('activity-log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
            
            // Keep only last 50 entries
            const entries = log.querySelectorAll('.log-entry');
            if (entries.length > 50) {
                entries[0].remove();
            }
        }
        
        function updateTime() {
            const now = new Date();
            const timeString = now.toLocaleTimeString();
            
            // Update forecast time if element exists
            const forecastTimeEl = document.getElementById('forecast-time');
            if (forecastTimeEl && forecastTimeEl.textContent === '--:--') {
                forecastTimeEl.textContent = timeString;
            }
        }
        
        // Event Handlers
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Mouse controls for camera
        let mouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        
        document.addEventListener('mousedown', (event) => {
            mouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        });
        
        document.addEventListener('mouseup', () => {
            mouseDown = false;
        });
        
        document.addEventListener('mousemove', (event) => {
            if (!mouseDown) return;
            
            const deltaX = event.clientX - mouseX;
            const deltaY = event.clientY - mouseY;
            
            camera.position.x += deltaX * 0.01;
            camera.position.y -= deltaY * 0.01;
            camera.lookAt(0, 0, 0);
            
            mouseX = event.clientX;
            mouseY = event.clientY;
        });
        
        // Zoom controls
        document.addEventListener('wheel', (event) => {
            const zoom = event.deltaY * 0.01;
            camera.position.multiplyScalar(1 + zoom);
            camera.position.clampLength(10, 100);
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (event) => {
            switch(event.key.toLowerCase()) {
                case 'c':
                    simulateCME();
                    break;
                case 'a':
                    analyzeWeather();
                    break;
                case 'f':
                    generateForecast();
                    break;
                case 'n':
                    loadNASAData();
                    break;
                case 'r':
                    toggleAurora();
                    break;
                case 'e':
                    exportData();
                    break;
                case ' ':
                    event.preventDefault();
                    // Reset camera position
                    camera.position.set(0, 10, 30);
                    camera.lookAt(0, 0, 0);
                    break;
            }
        });
        
        // Help Center Functions
        function openHelpCenter() {
            document.getElementById('helpCenter').classList.add('active');
            logMessage('Help Center opened', 'normal');
        }
        
        function closeHelpCenter() {
            document.getElementById('helpCenter').classList.remove('active');
            logMessage('Help Center closed', 'normal');
        }
        
        function showHelpSection(sectionId) {
            // Hide all content sections
            document.querySelectorAll('.help-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Hide all nav buttons
            document.querySelectorAll('.help-nav-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected content and activate button
            document.getElementById(`help-${sectionId}`).classList.add('active');
            event.target.classList.add('active');
        }
        
        // Close help center with Escape key
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                closeHelpCenter();
            }
        });
        
        // Initialize the observatory
        init();
    </script>
</body>
</html>